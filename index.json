[{"content":"Dear 嘉玲、凱宇老師：）\n上次課前談話沒說出口的，想要謝謝你們！ 雖然是去年9月左右才認識啟點 但感覺你們的聲音已經陪伴我好一段時間 從敲門這個節目開始覺得很幸運能認識你們 上次問我是哪一集觸動到我 仔細回想，當時是從搜尋看到的 我的習慣像看影集一樣，不是別人推薦的不管有沒有連貫我都會從第一集開始 主要是被輕鬆有趣的談話吸引吧 小到開場偶爾的卡詞都讓我覺得特別真實 我當時的情緒狀態特別低落也特別封閉什麼聲音都聽不進進去 打開會追的影集就像在播背景音樂一樣， 人在但靈魂不知道漂到哪裡去了 身邊有想幫助我的人，但我就像一塊木頭沒有任何反應 一開始聽發現就那麼自然的讓我會心一笑了 漸漸的你們輸出的內容就一點點流進來 像旁敲側擊一樣 我也說不清楚是什麼準確的東西 感覺原本很僵固的那一塊開始悄悄地鬆動了\n上次有提到真的讓我有感觸 開始思考我自己到底需要得到什麼幫助的是第12集 我之前的狀態大概就是知道自己需要幫助但說不清楚想要什麼 確實就是抱著去看醫生希望問題就能得到解決 也有一點賭氣不想好起來，可以說是耗著頂多讓我能勉強維持繼續工作不要放棄 那一集你們很真實的表達了你們所能做的，還有從你們角度看到的東西 我才意識到當時看診的醫師碰到我應該覺得很無力吧\n後來開始聽裘我呀、有聲書評、一天聽一點到最近的心理小學堂 很喜歡聽你們用心製作分享的內容 謝謝你們(希望能夠幫我轉達這份感謝給怡璇、媗甯等所有用心付出製作這些內容的你們)\n決定是否要走進實體課程我想了很久\n像你們問我對這堂課有什麼期望\n我一開始回答沒有其實是因為更清楚地知道你們扮演的角色\n是陪伴每一個來到裡的學員，用你們的專業帶我們用不同角度抑或去看見各自心裡面埋在更深的東西 主要是需要願意把自己打開才有可能在這門課程有所收穫。\n我可能有滿多議題要解決，不是這門課都能得到解答，也或許不是所有東西都需要答案 從上一次面談應該可以感覺到我不是一個有自信的人\n我知道怎麼做一個乖女兒、好學生、好員工(別人期待的樣子)\n但我不太會照顧到自己的需要\n不會肯定自己、沒有辦法給自己力量、好好的跟自己相處。 所以這應該是我現階段最需要的 好好的把自己搞清楚才有餘力去照顧到其他關係。\n選擇踏進來的我應該是準備好了 我知道會是一段痛苦的過程 我當下組織語言的能力比較弱，不知道怎麼回答就會卡住\n你們可能會常常碰到我的沉默、或是一個含糊的回答\n有時候是找不到精準描述的詞彙、或是沒有想過這種可能\n給我選擇或是比較明確的例子，可能可以引導我表達出我當下更準確的想法\n或是留給我一些時間思考，你們的建議或提問我都會很認真的在聽\n如果沒有馬上的反饋通常表示我需要回去消化一下，對我來說用寫的應該可以表達得更清楚\n期待你們持續推出的內容以及未來課程，謝謝你們！\n天韻\n","permalink":"https://tientiensmile.github.io/posts/life/20220227/","summary":"Dear 嘉玲、凱宇老師：）\n上次課前談話沒說出口的，想要謝謝你們！ 雖然是去年9月左右才認識啟點 但感覺你們的聲音已經陪伴我好一段時間 從敲門這個節目開始覺得很幸運能認識你們 上次問我是哪一集觸動到我 仔細回想，當時是從搜尋看到的 我的習慣像看影集一樣，不是別人推薦的不管有沒有連貫我都會從第一集開始 主要是被輕鬆有趣的談話吸引吧 小到開場偶爾的卡詞都讓我覺得特別真實 我當時的情緒狀態特別低落也特別封閉什麼聲音都聽不進進去 打開會追的影集就像在播背景音樂一樣， 人在但靈魂不知道漂到哪裡去了 身邊有想幫助我的人，但我就像一塊木頭沒有任何反應 一開始聽發現就那麼自然的讓我會心一笑了 漸漸的你們輸出的內容就一點點流進來 像旁敲側擊一樣 我也說不清楚是什麼準確的東西 感覺原本很僵固的那一塊開始悄悄地鬆動了\n上次有提到真的讓我有感觸 開始思考我自己到底需要得到什麼幫助的是第12集 我之前的狀態大概就是知道自己需要幫助但說不清楚想要什麼 確實就是抱著去看醫生希望問題就能得到解決 也有一點賭氣不想好起來，可以說是耗著頂多讓我能勉強維持繼續工作不要放棄 那一集你們很真實的表達了你們所能做的，還有從你們角度看到的東西 我才意識到當時看診的醫師碰到我應該覺得很無力吧\n後來開始聽裘我呀、有聲書評、一天聽一點到最近的心理小學堂 很喜歡聽你們用心製作分享的內容 謝謝你們(希望能夠幫我轉達這份感謝給怡璇、媗甯等所有用心付出製作這些內容的你們)\n決定是否要走進實體課程我想了很久\n像你們問我對這堂課有什麼期望\n我一開始回答沒有其實是因為更清楚地知道你們扮演的角色\n是陪伴每一個來到裡的學員，用你們的專業帶我們用不同角度抑或去看見各自心裡面埋在更深的東西 主要是需要願意把自己打開才有可能在這門課程有所收穫。\n我可能有滿多議題要解決，不是這門課都能得到解答，也或許不是所有東西都需要答案 從上一次面談應該可以感覺到我不是一個有自信的人\n我知道怎麼做一個乖女兒、好學生、好員工(別人期待的樣子)\n但我不太會照顧到自己的需要\n不會肯定自己、沒有辦法給自己力量、好好的跟自己相處。 所以這應該是我現階段最需要的 好好的把自己搞清楚才有餘力去照顧到其他關係。\n選擇踏進來的我應該是準備好了 我知道會是一段痛苦的過程 我當下組織語言的能力比較弱，不知道怎麼回答就會卡住\n你們可能會常常碰到我的沉默、或是一個含糊的回答\n有時候是找不到精準描述的詞彙、或是沒有想過這種可能\n給我選擇或是比較明確的例子，可能可以引導我表達出我當下更準確的想法\n或是留給我一些時間思考，你們的建議或提問我都會很認真的在聽\n如果沒有馬上的反饋通常表示我需要回去消化一下，對我來說用寫的應該可以表達得更清楚\n期待你們持續推出的內容以及未來課程，謝謝你們！\n天韻","title":"20220227"},{"content":"願意聽進去了再次回到診間\n之前跟惠怡醫師也建立了一定的信任跟默契為什麼會想要換醫師\n像你說的換醫師對對來說是一件辛苦的事情\n所有的事情都需要重新來過跟適應\n這是那段時間沒有換的主要原因\n惠怡醫師給了我一定的幫助跟支持陪我走過那一段狀態很不好的時間\n其實當時的我並不知道自己希望得到什麼樣的幫助\n只是覺得快要沒辦法正常生活跟工作而來尋求協助\n她能給予我的幫助有限，因為當時的我並不願意把自己打開\n不願意接受諮商，是因為還在一些事情剛發生的情緒裡，我只想逃走把自己關起來\n當我不願意把自己打開強迫自己去也只是在浪費資源\n","permalink":"https://tientiensmile.github.io/posts/life/20220226/","summary":"願意聽進去了再次回到診間\n之前跟惠怡醫師也建立了一定的信任跟默契為什麼會想要換醫師\n像你說的換醫師對對來說是一件辛苦的事情\n所有的事情都需要重新來過跟適應\n這是那段時間沒有換的主要原因\n惠怡醫師給了我一定的幫助跟支持陪我走過那一段狀態很不好的時間\n其實當時的我並不知道自己希望得到什麼樣的幫助\n只是覺得快要沒辦法正常生活跟工作而來尋求協助\n她能給予我的幫助有限，因為當時的我並不願意把自己打開\n不願意接受諮商，是因為還在一些事情剛發生的情緒裡，我只想逃走把自己關起來\n當我不願意把自己打開強迫自己去也只是在浪費資源","title":"20220226"},{"content":"我知道自己心裡面是匱乏被愛的\n成長過程都是靜靜的看著身邊發生的事情\n在外面不管是開心還是生氣很少表現出特別大的情緒波瀾\n可能要從國中說起吧 我爸爸是國中老師，我就自然地就讀他任職的學校\n幼稚園、國小下課後通常都是去爸爸的辦公室等他下班一起回家 所以很多爸爸的同事是看我長大的\n當進到國中其實我爸不會特別給我壓力\n但在那個環境自然的就會受到比其他同學更多的照顧吧\n任課老師、同學都知道你是誰誰誰的小孩\n我對那時候的印象就是有一次英文課被點名抽背一段 我沒有背出來就跟其他也沒背出來的同學一樣被罰站了一會兒 但對當時的我覺得最不舒服的是總是會聽到類似「我要怎麼跟你爸交代」這種話 另一次是模擬考作文拿了個3級分(滿分是6級，我文筆沒有特別好通常都是4,5級)\n那天班導師的課老師就說一次模擬考沒什麼，不用太在意那個分數\n等國文課拿到成績我知道那段話是說給我聽的 下課我爸就出先在我教室門口 原本真的沒什麼的是情常常會被這樣過度關心 想說的不想說的不管實際上有沒有，我都覺得反正總會傳到我爸那裡 我爸不會特別給我壓力，他知道我己經會給自己很大的壓力了\n大概是從那個時候開始不再跟家人分享我學校的生活 也沒有特別有可以說心事的朋友\n因為在學校的環境就感覺所有行徑都有人在看\n可能實際上沒那麼嚴重但大概是我那時候的感受\n","permalink":"https://tientiensmile.github.io/posts/life/20220225/","summary":"我知道自己心裡面是匱乏被愛的\n成長過程都是靜靜的看著身邊發生的事情\n在外面不管是開心還是生氣很少表現出特別大的情緒波瀾\n可能要從國中說起吧 我爸爸是國中老師，我就自然地就讀他任職的學校\n幼稚園、國小下課後通常都是去爸爸的辦公室等他下班一起回家 所以很多爸爸的同事是看我長大的\n當進到國中其實我爸不會特別給我壓力\n但在那個環境自然的就會受到比其他同學更多的照顧吧\n任課老師、同學都知道你是誰誰誰的小孩\n我對那時候的印象就是有一次英文課被點名抽背一段 我沒有背出來就跟其他也沒背出來的同學一樣被罰站了一會兒 但對當時的我覺得最不舒服的是總是會聽到類似「我要怎麼跟你爸交代」這種話 另一次是模擬考作文拿了個3級分(滿分是6級，我文筆沒有特別好通常都是4,5級)\n那天班導師的課老師就說一次模擬考沒什麼，不用太在意那個分數\n等國文課拿到成績我知道那段話是說給我聽的 下課我爸就出先在我教室門口 原本真的沒什麼的是情常常會被這樣過度關心 想說的不想說的不管實際上有沒有，我都覺得反正總會傳到我爸那裡 我爸不會特別給我壓力，他知道我己經會給自己很大的壓力了\n大概是從那個時候開始不再跟家人分享我學校的生活 也沒有特別有可以說心事的朋友\n因為在學校的環境就感覺所有行徑都有人在看\n可能實際上沒那麼嚴重但大概是我那時候的感受","title":"20220225"},{"content":"Combination Operators  將多個 Observable 組合成單個 Observable 運算符。  startWith  開始從某個 Observable 發出元素之前發出指定的元素序列。   每個連續的 startWith 元素都將在前一個 startWith 元素之前添加。\n let disposeBag = DisposeBag() Observable.of(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;) .startWith(\u0026#34;1\u0026#34;) .startWith(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;) .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) 印出結果\na b c 1 A B C D merge zip combineLatest switchLatest withLatestFrom  ","permalink":"https://tientiensmile.github.io/posts/rxswift/rxswift_combination_operators/","summary":"Combination Operators  將多個 Observable 組合成單個 Observable 運算符。  startWith  開始從某個 Observable 發出元素之前發出指定的元素序列。   每個連續的 startWith 元素都將在前一個 startWith 元素之前添加。\n let disposeBag = DisposeBag() Observable.of(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;) .startWith(\u0026#34;1\u0026#34;) .startWith(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;) .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) 印出結果\na b c 1 A B C D merge zip combineLatest switchLatest withLatestFrom  ","title":"RxSwift - Combination Operators"},{"content":"對我來說其實用寫的比用說的容易一些 第一次見面前原本有想寫一些東西 但還是想用說的試試看\n結果很多東西還是說不清楚\n上次提到出現狀況是很多因素加總而成的 跟家人不太親近是一個原因\n更直接關係的應該是1年半前結束了一段3年的感情\n壓死駱駝的最後一根稻草是工作上原本一起合作比我資深的夥伴去開發新產品 變成我帶一個新人一起扛下這支產品\n當時的我其實也才轉職寫程式半年左右\n變成我主導後感覺得自己能力不足\n有很強烈的無力挫敗感\n大概是從國中開始每隔2-3年情緒會開始變得低落\n那時候總是推給課業壓力大\n其實是因為一直很孤單吧\n不太會跟家人分享自己的生活\n個性比較內斂害羞跟所有人都保持了一定的距離\n所有事幾乎都悶在心裡\n每次升學換了一個新環境一開始感覺會好一些\n但過一陣子後又會再來一次\n大三有一段時間變得比較嚴重\n很難去上課 很不願意跟人溝通\n不知道在害怕什麼但講話或是坐在教室裡都會發抖\n那是第一次意識到自己有一些行為開始無法控制 那段時間每週會去學校的諮商中心跟老師約談 好起來的原因是有慢慢重新回到熟悉的田徑場參與訓練 研究所申請到台北的研究所離開了當時的環境\n最久一段時間沒有經歷這種低潮是進到一段感情中 中間她陪我經歷父母離婚、找工作、轉職等等 有她在感覺讓我變得勇敢一些 如果那些時候沒有她\n我不會選擇轉職 可能還是待在原本的工作然後像現在的狀態一樣\n","permalink":"https://tientiensmile.github.io/posts/life/20220216/","summary":"對我來說其實用寫的比用說的容易一些 第一次見面前原本有想寫一些東西 但還是想用說的試試看\n結果很多東西還是說不清楚\n上次提到出現狀況是很多因素加總而成的 跟家人不太親近是一個原因\n更直接關係的應該是1年半前結束了一段3年的感情\n壓死駱駝的最後一根稻草是工作上原本一起合作比我資深的夥伴去開發新產品 變成我帶一個新人一起扛下這支產品\n當時的我其實也才轉職寫程式半年左右\n變成我主導後感覺得自己能力不足\n有很強烈的無力挫敗感\n大概是從國中開始每隔2-3年情緒會開始變得低落\n那時候總是推給課業壓力大\n其實是因為一直很孤單吧\n不太會跟家人分享自己的生活\n個性比較內斂害羞跟所有人都保持了一定的距離\n所有事幾乎都悶在心裡\n每次升學換了一個新環境一開始感覺會好一些\n但過一陣子後又會再來一次\n大三有一段時間變得比較嚴重\n很難去上課 很不願意跟人溝通\n不知道在害怕什麼但講話或是坐在教室裡都會發抖\n那是第一次意識到自己有一些行為開始無法控制 那段時間每週會去學校的諮商中心跟老師約談 好起來的原因是有慢慢重新回到熟悉的田徑場參與訓練 研究所申請到台北的研究所離開了當時的環境\n最久一段時間沒有經歷這種低潮是進到一段感情中 中間她陪我經歷父母離婚、找工作、轉職等等 有她在感覺讓我變得勇敢一些 如果那些時候沒有她\n我不會選擇轉職 可能還是待在原本的工作然後像現在的狀態一樣","title":"20220216"},{"content":"1~10，如果5分是正常現在在幾分呢? 3,4分\n我沒說出口的謝謝你們，謝謝你們的聲音陪我度過很多日子\n說不清楚準確是什麼，但那些東西就慢慢聽進去了\n有時間再把那些觸動紀錄下來\n我說不期待什麼是因為我知道你們能做的有限\n尤其我又不太會把自己說清楚\n但我可以確定的是我願意在這裡把外皮卸掉\n去看見裡面的自己發生了什麼事情\n然後希望長出一點支撐自己的力量。\n謝謝你們耐心的聽我說話\n我的沉默是因為我不知道該如何回答\n有時候是因為顧慮該不該說而卡住\n有時候是沒想過有這種可能當下沒有答案\n我的反應比較遲鈍\n回到一個人的狀態才會想到當時想回應的東西\n如果有下一次再跟你們分享。\n課前功課\n換一位醫師好好吃藥\n先讓作息正常頭腦才能好好運作。\n想問的\n如果那個行為是建立在信任之上的該怎麼界定？\n","permalink":"https://tientiensmile.github.io/posts/life/20220215/","summary":"1~10，如果5分是正常現在在幾分呢? 3,4分\n我沒說出口的謝謝你們，謝謝你們的聲音陪我度過很多日子\n說不清楚準確是什麼，但那些東西就慢慢聽進去了\n有時間再把那些觸動紀錄下來\n我說不期待什麼是因為我知道你們能做的有限\n尤其我又不太會把自己說清楚\n但我可以確定的是我願意在這裡把外皮卸掉\n去看見裡面的自己發生了什麼事情\n然後希望長出一點支撐自己的力量。\n謝謝你們耐心的聽我說話\n我的沉默是因為我不知道該如何回答\n有時候是因為顧慮該不該說而卡住\n有時候是沒想過有這種可能當下沒有答案\n我的反應比較遲鈍\n回到一個人的狀態才會想到當時想回應的東西\n如果有下一次再跟你們分享。\n課前功課\n換一位醫師好好吃藥\n先讓作息正常頭腦才能好好運作。\n想問的\n如果那個行為是建立在信任之上的該怎麼界定？","title":"20220215"},{"content":"take  從 Observable 中發出頭 n 個元素，忽略後面的元素直到序列結束。   let disposeBag = DisposeBag() Observable.of(\u0026#34;🐱\u0026#34;, \u0026#34;🐰\u0026#34;, \u0026#34;🐶\u0026#34;, \u0026#34;🐸\u0026#34;, \u0026#34;🐷\u0026#34;, \u0026#34;🐵\u0026#34;) .take(3) .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) 印出結果\n🐱 🐰 🐶 distinctUntilChanged  阻止 Observable 發出相同的元素。如果後一個元素和前一個元素相同，將不會發出來，若後一個元素和前一個元素不同才會被發出來。   let disposeBag = DisposeBag() Observable.of(\u0026quot;🐱\u0026quot;, \u0026quot;🐷\u0026quot;, \u0026quot;🐱\u0026quot;, \u0026quot;🐱\u0026quot;, \u0026quot;🐱\u0026quot;, \u0026quot;🐵\u0026quot;, \u0026quot;🐱\u0026quot;) .distinctUntilChanged() .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) 印出結果\n🐱 🐷 🐱 🐵 🐱 ","permalink":"https://tientiensmile.github.io/posts/rxswift/rxswift_operators_2/","summary":"take  從 Observable 中發出頭 n 個元素，忽略後面的元素直到序列結束。   let disposeBag = DisposeBag() Observable.of(\u0026#34;🐱\u0026#34;, \u0026#34;🐰\u0026#34;, \u0026#34;🐶\u0026#34;, \u0026#34;🐸\u0026#34;, \u0026#34;🐷\u0026#34;, \u0026#34;🐵\u0026#34;) .take(3) .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) 印出結果\n🐱 🐰 🐶 distinctUntilChanged  阻止 Observable 發出相同的元素。如果後一個元素和前一個元素相同，將不會發出來，若後一個元素和前一個元素不同才會被發出來。   let disposeBag = DisposeBag() Observable.of(\u0026quot;🐱\u0026quot;, \u0026quot;🐷\u0026quot;, \u0026quot;🐱\u0026quot;, \u0026quot;🐱\u0026quot;, \u0026quot;🐱\u0026quot;, \u0026quot;🐵\u0026quot;, \u0026quot;🐱\u0026quot;) .distinctUntilChanged() .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) 印出結果\n🐱 🐷 🐱 🐵 🐱 ","title":"RxSwift - take、distinctUntilChanged"},{"content":"combineLatest  將多個 Observables 中最新的元素透過一個函數組合起來，然後將結果發出來。  let disposeBag = DisposeBag() let first = PublishSubject\u0026lt;String\u0026gt;() let second = PublishSubject\u0026lt;String\u0026gt;() Observable.combineLatest(first, second) { $0 + $1 } .dubscribe(onNext: { print($0) }) .disposed(by: disposeBag) first.onNext(\u0026#34;1\u0026#34;) second.onNext(\u0026#34;A\u0026#34;) first.onNext(\u0026#34;2\u0026#34;) second.onNext(\u0026#34;B\u0026#34;) second.onNext(\u0026#34;C\u0026#34;) second.onNext(\u0026#34;D\u0026#34;) first.onNext(\u0026#34;3\u0026#34;) first.onNext(\u0026#34;4\u0026#34;) 印出結果\n1A 2A 2B 2C 2D 3D 4D skip  跳過 Observable 中頭 n 個元素  do  使用 do 來監聽事件的生命週期，它會在每一次事件發送前被調用。 它和 subscribe 一樣，可以通過不同的閉包回調不同類型的事件。 如：do(onNext: ) 在 subscribe(onNext:) 前，do(onCompleted:) 在 subscribe(onCompleted:) 前調用。  let observable = Observable.of(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) observable .do(onNext: { element in print(\u0026#34;Intercepted Next：\u0026#34;, element) }, onError: { error in print(\u0026#34;Intercepted Error：\u0026#34;, error) }, onCompleted: { print(\u0026#34;Intercepted Completed\u0026#34;) }, onDispose: { print(\u0026#34;Intercepted Disposed\u0026#34;) }) .subscribe(onNext: { element in print(element) }, onError: { error in print(error) }, onCompleted: { print(\u0026#34;completed\u0026#34;) }, onDisposed: { print(\u0026#34;disposed\u0026#34;) }) 印出結果\nIntercepted Next： A A Intercepted Next： B B Intercepted Next： C C Intercepted Completed completed disposed Intercepted Disposed ","permalink":"https://tientiensmile.github.io/posts/rxswift/rxswift_operators_1/","summary":"combineLatest  將多個 Observables 中最新的元素透過一個函數組合起來，然後將結果發出來。  let disposeBag = DisposeBag() let first = PublishSubject\u0026lt;String\u0026gt;() let second = PublishSubject\u0026lt;String\u0026gt;() Observable.combineLatest(first, second) { $0 + $1 } .dubscribe(onNext: { print($0) }) .disposed(by: disposeBag) first.onNext(\u0026#34;1\u0026#34;) second.onNext(\u0026#34;A\u0026#34;) first.onNext(\u0026#34;2\u0026#34;) second.onNext(\u0026#34;B\u0026#34;) second.onNext(\u0026#34;C\u0026#34;) second.onNext(\u0026#34;D\u0026#34;) first.onNext(\u0026#34;3\u0026#34;) first.onNext(\u0026#34;4\u0026#34;) 印出結果\n1A 2A 2B 2C 2D 3D 4D skip  跳過 Observable 中頭 n 個元素  do  使用 do 來監聽事件的生命週期，它會在每一次事件發送前被調用。 它和 subscribe 一樣，可以通過不同的閉包回調不同類型的事件。 如：do(onNext: ) 在 subscribe(onNext:) 前，do(onCompleted:) 在 subscribe(onCompleted:) 前調用。  let observable = Observable.","title":"RxSwift - combineLatest、skip、do"},{"content":"ObservableObject 和 @ObservedObject  ObservableObject 是一個 protocol，要求實現協議的類型為 class，有一個需要實作的屬性 objectWillChange。 當數據將要發生改變時，這個屬性用來向外進行「廣播」，它的訂閱者(一般是 View 相關的邏輯)在收到通知後，對 View 進行刷新。 創建遵從 ObservableObject 協議的類別後，實際在 View 裡使用需要將此物件宣告為 @ObservedObject。  範例：點擊按鈕擲骰子  使用 PassthroughSubject 中 send() 方法通知事件將要發生。 PassthroughSubject 於 Combine 框架中，將於後續介紹。\n  ContentView 中 model 為 reference type，使用 @ObservedObject 將它和 ContentView 關聯起來。當 model 中的屬性 diceState 將要改變，objectWillChange 就會發出事件，使得 body 被調用進行UI刷新。  struct ContentView: View { @ObservedObject private var model = DiceModel() var body: some View { CounterButton(diceState: $model.diceState) } } class DiceModel: ObservableObject { let objectWillChange = PassthroughSubject\u0026lt;Void, Never\u0026gt;() var diceState: DiceState = .one { willSet { objectWillChange.send() } } } enum DiceState: Int { case one = 1 case two = 2 case three = 3 case four = 4 case five = 5 case six = 6 } @Published  在 ObservableObject 中，每個對介面可能產生影響的屬性都可以如 diceState 的 willSet 那樣，手動調用 objectWillChange.send()。若 model 有很多屬性逐一添加 willSet 很麻煩且重複。 簡化寫法為：省略宣告 objectWillChange，並將屬性標記為 Published。  class DiceModel: ObservableObject { @Published var diceState: DiceState = .one } @EnvironmentObject  當多個 View 需要訪問到同一個 model，使用 @ObservedObject 需要大量的屬性傳遞，改用 @EnvironmentObject 可以便捷的達到大批量共享。 跟單例很像，只要在 View 層級以上，不論在哪裡都可以訪問到這個環境對象。  struct ContentView: View { @EnvironmentObject var model: DiceModel var body: some View { CounterButton() } } struct CounterButton: View { @EnvironmentObject var model: DiceModel var body: some View { Button { let value = Int.random(in: 1...6) let dice = DiceState(rawValue: value) model.diceState = dice ?? .one } label: { Circle() .frame(width: 150, height: 150, alignment: .center) .foregroundColor(.blue) .overlay { Text(\u0026#34;\\(model.diceState.rawValue)\u0026#34;) .font(.system(size:72, weight: .bold)) .foregroundColor(.white) } } } } 在創建 ContentView 的地方注入 environmentObject\n@main struct SwiftUIDemoApp: App { var body: some Scene { WindowGroup { ContentView().environmentObject(DiceModel()) } } } 總結  @State 和 @Binding 提供 View 內部的狀態儲存，應是簡單的 value type 標記為 private 僅供內部使用。 ObservableObject中@ObservedObject和 @EnvironmentObject 則是針對跨越 View 層級的狀態共享，可以處理較複雜的數據類型，為 reference type。需要在數據變化時向外發送通知，來觸發介面刷新。 建議一開始可以先選擇使用 @ObservedObject，若發現狀態可以被限制在同一個 View 層級，則改用 @State；若狀態需要大量共享，則改用 @EnvironmentObject  ","permalink":"https://tientiensmile.github.io/posts/swiftui/swiftui_observableobject/","summary":"ObservableObject 和 @ObservedObject  ObservableObject 是一個 protocol，要求實現協議的類型為 class，有一個需要實作的屬性 objectWillChange。 當數據將要發生改變時，這個屬性用來向外進行「廣播」，它的訂閱者(一般是 View 相關的邏輯)在收到通知後，對 View 進行刷新。 創建遵從 ObservableObject 協議的類別後，實際在 View 裡使用需要將此物件宣告為 @ObservedObject。  範例：點擊按鈕擲骰子  使用 PassthroughSubject 中 send() 方法通知事件將要發生。 PassthroughSubject 於 Combine 框架中，將於後續介紹。\n  ContentView 中 model 為 reference type，使用 @ObservedObject 將它和 ContentView 關聯起來。當 model 中的屬性 diceState 將要改變，objectWillChange 就會發出事件，使得 body 被調用進行UI刷新。  struct ContentView: View { @ObservedObject private var model = DiceModel() var body: some View { CounterButton(diceState: $model.diceState) } } class DiceModel: ObservableObject { let objectWillChange = PassthroughSubject\u0026lt;Void, Never\u0026gt;() var diceState: DiceState = .","title":"SwiftUI - ObservableObject"},{"content":"屬性包裝、投射屬性  由 @ 修飾的屬性稱為屬性包裝(Property Wrapper)。 @State、@Binding、@ObjectBinding、@EnvironmentObject都是 @propertyWrapper 修飾的 struct。 對一個由 @ 修飾的屬性，在它前面使用 $ 取得的值，被稱為投射屬性(Projection Property)。 並不是所有的 @ 屬性都提供 $ 的投射訪問方式。  @State  @State 修飾的屬性會被自動轉換為一對 setter 和 getter 對這個屬性進行賦值的操作，它的 body 會被再次調用，進行 View 的刷新。 但由於是 value type ，在不同物件傳遞時透過複製值，因此經過不同層級底層改變並無法更新頂層的值。 訪問 @State 修飾的屬性，所有調用觸發的都是 wrappedValue。 使用 $ 訪問屬性，取得的是 projectedValue ，為一個 Binding 類型的值。  SwiftUI 中 State 定義的關鍵部分\n@propertyWrapper public struct State\u0026lt;Value\u0026gt;: DynamicViewProperty, BindingConvertible { public var value: Value { get nonmutating set } public var wrappedValue: Value { get nonmutating set } public var projectedValue: Binding\u0026lt;Value\u0026gt; { get } init(initialValue value: Value) } 範例：點擊按鈕數字累加點擊次數 struct ContentView: View { @State private var count: Int = 0 var body: some View { Button { self.count += 1 } label: { Circle() .frame(width: 150, height: 150, alignment: .center) .foregroundColor(.blue) .overlay { Text(\u0026#34;\\(count)\u0026#34;) .font(.system(size:72, weight: .bold)) .foregroundColor(.white) } } } } @Binding  和 @State 類似，也是對屬性的修飾，但將 value type 轉換為 reference type。 對 @Binding 修飾的屬性進行賦值，改變的是其參考，因此可以在不同物件傳遞。  範例：同上(將按鈕定義為CounterButton)  CounterButton 中宣告 count 變數以 @Binding 修飾，在 ContentView 以 projectedValue 將 $counter 傳遞至 CounterButton，當點擊按鈕 count 值改變，畫面改變，counter亦跟著改變。   print(counter) 印出結果皆為 1, 2, 3\u0026hellip;\n  若 CounterButton 中宣告 count 變數以 @State 修飾，在 ContentView 以 wrappedValue 將 counter 傳遞至 CounterButton，當點擊按鈕 count 值改變，畫面改變，但 counter 不會跟著改變。   print(counter) 印出結果皆為 0\n struct ContentView: View { @State private var counter: Int = 0 var body: some View { CounterButton(count: $counter) { print(counter) } } } struct CounterButton: View { @Binding var count: Int var body: some View { Button { self.count += 1 } label: { Circle() .frame(width: 150, height: 150, alignment: .center) .foregroundColor(.blue) .overlay { Text(\u0026#34;\\(count)\u0026#34;) .font(.system(size:72, weight: .bold)) .foregroundColor(.white) } } } } ","permalink":"https://tientiensmile.github.io/posts/swiftui/swiftui_stateandbinding/","summary":"屬性包裝、投射屬性  由 @ 修飾的屬性稱為屬性包裝(Property Wrapper)。 @State、@Binding、@ObjectBinding、@EnvironmentObject都是 @propertyWrapper 修飾的 struct。 對一個由 @ 修飾的屬性，在它前面使用 $ 取得的值，被稱為投射屬性(Projection Property)。 並不是所有的 @ 屬性都提供 $ 的投射訪問方式。  @State  @State 修飾的屬性會被自動轉換為一對 setter 和 getter 對這個屬性進行賦值的操作，它的 body 會被再次調用，進行 View 的刷新。 但由於是 value type ，在不同物件傳遞時透過複製值，因此經過不同層級底層改變並無法更新頂層的值。 訪問 @State 修飾的屬性，所有調用觸發的都是 wrappedValue。 使用 $ 訪問屬性，取得的是 projectedValue ，為一個 Binding 類型的值。  SwiftUI 中 State 定義的關鍵部分\n@propertyWrapper public struct State\u0026lt;Value\u0026gt;: DynamicViewProperty, BindingConvertible { public var value: Value { get nonmutating set } public var wrappedValue: Value { get nonmutating set } public var projectedValue: Binding\u0026lt;Value\u0026gt; { get } init(initialValue value: Value) } 範例：點擊按鈕數字累加點擊次數 struct ContentView: View { @State private var count: Int = 0 var body: some View { Button { self.","title":"SwiftUI - 狀態(State)與綁定(Binding)"},{"content":" 適合 SwiftUI 的架構\n Redux 基本概念  App 為一個狀態機，狀態決定用戶介面。 這些狀態(State)都保存在一個 Store 物件中。 View 不能直接操作 State，只能通過發送 Action 的方式間接改變儲存在 Store 中的 State 。 Reducer 接受原有的 State 和發送過來的 Action，生成新的 State。 用新的 State 替換 Store 中原有的狀態，並用新的狀態來驅動更新介面。  Store 應用程式只有一個 Store，用來保存整個應用程式的 State。 可以透過 store.getState() 取得應用程式當前狀態，但不能直接修改。\nAction Action 為一個普通的物件，用來描述應用程式發生的事情，把數據傳遞給 Store 的唯一途徑。\nReducer Reducer.reduce(state: action:)是純函數，具體處理狀態的邏輯。\n 純函數：返回值只由調用時的參數決定，不依賴於任何系統狀態，也不改變其作用域之外的變量狀態的函數。\n struct Reducer { static func reduce(state: State, action: Action) -\u0026gt; State { return state.apply(item: action) } } ","permalink":"https://tientiensmile.github.io/posts/redux_intro/","summary":" 適合 SwiftUI 的架構\n Redux 基本概念  App 為一個狀態機，狀態決定用戶介面。 這些狀態(State)都保存在一個 Store 物件中。 View 不能直接操作 State，只能通過發送 Action 的方式間接改變儲存在 Store 中的 State 。 Reducer 接受原有的 State 和發送過來的 Action，生成新的 State。 用新的 State 替換 Store 中原有的狀態，並用新的狀態來驅動更新介面。  Store 應用程式只有一個 Store，用來保存整個應用程式的 State。 可以透過 store.getState() 取得應用程式當前狀態，但不能直接修改。\nAction Action 為一個普通的物件，用來描述應用程式發生的事情，把數據傳遞給 Store 的唯一途徑。\nReducer Reducer.reduce(state: action:)是純函數，具體處理狀態的邏輯。\n 純函數：返回值只由調用時的參數決定，不依賴於任何系統狀態，也不改變其作用域之外的變量狀態的函數。\n struct Reducer { static func reduce(state: State, action: Action) -\u0026gt; State { return state.apply(item: action) } } ","title":"Redux架構"},{"content":"Subjects 同時是 Observable 也是 Observer\nPublish Subject 訂閱之後才會收到發出的事件。\nlet subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.dispose() /// Issue 3 在dispose之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) let subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.onCompleted() /// Issue 3 在completed之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) completed Behavior Subject 需給定初始值，因爲訂閱它時，會得到初始值或訂閱前最後一個值。\nlet subject = BehaviorSubject(value: \u0026#34;Initial value\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 1\u0026#34;) /// 印出結果 next(Initial value) next(Issue 1) let subject = BehaviorSubject(value: \u0026#34;Initial value\u0026#34;) subject.onNext(\u0026#34;Last Issue\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 1\u0026#34;) /// 印出結果 next(Last Issue) next(Issue 1) Relay Subject 訂閱後可以收到指定數量最新訂閱前發出的事件。\nlet subject = ReplaySubject\u0026lt;String\u0026gt;.create(bufferSize: 2) subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.onNext(\u0026#34;Issue 3\u0026#34;) print(\u0026#34;[Subscription 1]\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 4\u0026#34;) subject.onNext(\u0026#34;Issue 5\u0026#34;) subject.onNext(\u0026#34;Issue 6\u0026#34;) print(\u0026#34;[Subscription 2]\u0026#34;) subject.subscribe { event in print(event) } /// 印出結果 ubscription 1] next(Issue 2) next(Issue 3) next(Issue 4) next(Issue 5) next(Issue 6) [Subscription 2] next(Issue 5) next(Issue 6) Variables  即將廢除由 BehaviorRelay 取代\n 為一個可以儲存值的Behavior Subject，我們可以對其屬性存取值。\nlet variable = Variable(\u0026#34;Initial value\u0026#34;) variable.value = \u0026#34;Hello world\u0026#34; variable.asObservable().subscribe { print($0) } /// 印出結果 next(Hello world) 訂閱一個字串陣列，當改變陣列內容就會收到事件得到當前陣列的內容。\nlet variable = Variable([String]()) variable.value.append(\u0026#34;Item 1\u0026#34;) variable.asObservable().subscribe { print($0) } variable.value.append(\u0026#34;Item 2\u0026#34;) /// 印出結果 next([\u0026#34;Item 1\u0026#34;]) next([\u0026#34;Item 1\u0026#34;, \u0026#34;Item 2\u0026#34;]) BehaviorRelay  需要 pod 'RxCocoa'\n  value 屬性限制為 get-only 更新值使用 accept()  let replay = BehaviorRelay(value: \u0026#34;Item 1\u0026#34;) replay.accept(\u0026#34;Hello world\u0026#34;) replay.asObservable() .subscribe { print($0) } /// 印出結果 next(Hello world) 值的更新為 accept 收到的值，若要累加需先從屬性中取出原本的值。\nlet replay = BehaviorRelay(value: [\u0026#34;Item 1\u0026#34;]) replay.accept([\u0026#34;Item 2\u0026#34;]) replay.asObservable() .subscribe { print($0) } replay.accept(replay.value + [\u0026#34;Item 3\u0026#34;]) /// 印出結果 next([\u0026#34;Item 2\u0026#34;]) next([\u0026#34;Item 2\u0026#34;, \u0026#34;Item 3\u0026#34;]) ","permalink":"https://tientiensmile.github.io/posts/rxswift/rxswift_subjects/","summary":"Subjects 同時是 Observable 也是 Observer\nPublish Subject 訂閱之後才會收到發出的事件。\nlet subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.dispose() /// Issue 3 在dispose之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) let subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.onCompleted() /// Issue 3 在completed之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) completed Behavior Subject 需給定初始值，因爲訂閱它時，會得到初始值或訂閱前最後一個值。","title":"RxSwift - Subjects"},{"content":"每一個 Observable 就只是一個序列(Sequence)而已。\nsubscribe 一個 observable，以訂閱UISlider為例，當滑動UISlider時值改變就會通知訂閱(subscride)的人。\n建立Observables 建立一個只有一個 element，值為1的observable\nlet observable = Observable.just(1) 建立一個三個element，型別為int的observable\nlet observable2 = Observable.of(1,2,3) 建立一個只有一個element，為int陣列的observable\nlet observable3 = Observable.of([1,2,3]) 用from遍歷陣列中每一個element，相當於observable2\nlet observable4 = Observable.from([1,2,3]) 建立Subscriptions observable4.subscribe { event in print(event) } /// 印出結果 next(1) next(2) next(3) completed /// 取得Observable中的值 observable4.subscribe { event in if let element = event.element { print(element) } } /// 較簡易取得element的方法 observable4.subscribe(onNext: { element in print(element) }) /// 印出結果 1 2 3 observable3.subscribe { event in print(event) } /// 印出結果 next([1, 2, 3]) completed 取得Observable中的值\nobservable3.subscribe(onNext: { element in print(element) }) /// 印出結果 [1, 2, 3] Event - 事件 enum Event\u0026lt;Element\u0026gt; { case next(Element) case error(Swift.Error) case completed }  next：序列產生一個新的元素 completed：序列的所有元素都成功產生，整個序列已經完成 error：創建序列時產生了一個錯誤，導致序列終止  Disposing  當 Observable 有被訂閱(subscribe)，表示建立了訂閱者一直在觀察這個序列，因此當序列完成需要適當的 dispose 這些 subscriptions，否則會產生memory leak。\n 針對單個訂閱做dispose\nlet subscription4 = observable4.subscribe(onNext: { element in print(element) }) subscription4.dispose() 使用disposeBag，當序列完成自動進行dispose\nlet disposeBag = DisposeBag() Observable.of(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .subscribe { print($0) }.disposed(by: disposeBag) 另一種創建序列及訂閱的方法  調用 Observable.create 創建序列，在構建函數裡描述元素的產生過程。\n 當一個序列completed或是出現error就不會再觸發後續的事件\nObservable\u0026lt;String\u0026gt;.create { observer in observer.onNext(\u0026#34;A\u0026#34;) observer.onCompleted() observer.onNext(\u0026#34;B\u0026#34;) observer.onNext(\u0026#34;C\u0026#34;) return Disposables.create() }.subscribe { print($0) } onError: { print($0) } onCompleted: { print(\u0026#34;Completed\u0026#34;) } onDisposed: { print(\u0026#34;Disposed\u0026#34;) }.disposed(by: disposeBag) /// 印出結果 A Completed Disposed ","permalink":"https://tientiensmile.github.io/posts/rxswift/rxswift_observable/","summary":"每一個 Observable 就只是一個序列(Sequence)而已。\nsubscribe 一個 observable，以訂閱UISlider為例，當滑動UISlider時值改變就會通知訂閱(subscride)的人。\n建立Observables 建立一個只有一個 element，值為1的observable\nlet observable = Observable.just(1) 建立一個三個element，型別為int的observable\nlet observable2 = Observable.of(1,2,3) 建立一個只有一個element，為int陣列的observable\nlet observable3 = Observable.of([1,2,3]) 用from遍歷陣列中每一個element，相當於observable2\nlet observable4 = Observable.from([1,2,3]) 建立Subscriptions observable4.subscribe { event in print(event) } /// 印出結果 next(1) next(2) next(3) completed /// 取得Observable中的值 observable4.subscribe { event in if let element = event.element { print(element) } } /// 較簡易取得element的方法 observable4.subscribe(onNext: { element in print(element) }) /// 印出結果 1 2 3 observable3.subscribe { event in print(event) } /// 印出結果 next([1, 2, 3]) completed 取得Observable中的值","title":"RxSwift - Observable 可監聽序列"},{"content":"觀察者是用來監聽序列，當收到事件作出響應。\n建立觀察者 對一個 Observable 進行 subscribe。事件發生時於後面的 onNext、onError、onCompleted作出響應。\ntap.subscribe(onNext: { [weak self] in self?.showAlert() }, onError: { error in print(\u0026#34;發生錯誤： \\(error.localizedDescription)\u0026#34;) }, onCompleted: { print(\u0026#34;完成任務\u0026#34;) }) AnyObserver AnyObserver 可以用來描述任意一種觀察者。\n範例：印出網路請求結果\nURLSession.shared.rx.data(request: URLRequest(url: url)) .subscribe(onNext: { data in print(\u0026#34;Data Task Success with count: \\(data.count)\u0026#34;) }, onError: { error in print(\u0026#34;Data Task Error: \\(error)\u0026#34;) }) .disposed(by: disposeBag) 可以改寫為\nlet observer: AnyObserver\u0026lt;Data\u0026gt; = AnyObserver { (event) in switch event { case .next(let data): print(\u0026#34;Data Task Success with count: \\(data.count)\u0026#34;) case .error(let error): print(\u0026#34;Data Task Error: \\(error)\u0026#34;) default: break } } URLSession.shared.rx.data(request: URLRequest(url: url)) .subscribe(observer) .disposed(by: disposeBag) Binder  Binder 不會處理錯誤事件 確保綁定都是在給定的 Scheduler 上執行 (默認為 MainScheduler)  範例： 这个观察者是一个 UI 观察者，所以它在响应事件时，只会处理 next 事件，并且更新 UI 的操作需要在主线程上执行。\nlet observer: AnyObserver\u0026lt;Bool\u0026gt; = AnyObserver { [weak self] (event) in switch event { case .next(let isHidden): self?.usernameValidOutlet.isHidden = isHidden default: break } } usernameValid .bind(to: observer) .disposed(by: disposeBag) ","permalink":"https://tientiensmile.github.io/posts/rxswift/rxswift_observer/","summary":"觀察者是用來監聽序列，當收到事件作出響應。\n建立觀察者 對一個 Observable 進行 subscribe。事件發生時於後面的 onNext、onError、onCompleted作出響應。\ntap.subscribe(onNext: { [weak self] in self?.showAlert() }, onError: { error in print(\u0026#34;發生錯誤： \\(error.localizedDescription)\u0026#34;) }, onCompleted: { print(\u0026#34;完成任務\u0026#34;) }) AnyObserver AnyObserver 可以用來描述任意一種觀察者。\n範例：印出網路請求結果\nURLSession.shared.rx.data(request: URLRequest(url: url)) .subscribe(onNext: { data in print(\u0026#34;Data Task Success with count: \\(data.count)\u0026#34;) }, onError: { error in print(\u0026#34;Data Task Error: \\(error)\u0026#34;) }) .disposed(by: disposeBag) 可以改寫為\nlet observer: AnyObserver\u0026lt;Data\u0026gt; = AnyObserver { (event) in switch event { case .next(let data): print(\u0026#34;Data Task Success with count: \\(data.","title":"RxSwift - Observer 觀察者"}]