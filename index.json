[{"content":"Dear 嘉玲、凱宇老師：）\n上次課前談話沒說出口的，想要謝謝你們！ 雖然是去年9月左右才認識啟點 但感覺你們的聲音已經陪伴我好一段時間 從敲門這個節目開始覺得很幸運能認識你們 上次問我是哪一集觸動到我 仔細回想，當時是從搜尋看到的 我的習慣像看影集一樣，不是別人推薦的不管有沒有連貫我都會從第一集開始 主要是被輕鬆有趣的談話吸引吧 小到開場偶爾的卡詞都讓我覺得特別真實 我當時的情緒狀態特別低落也特別封閉什麼聲音都聽不進進去 打開會追的影集就像在播背景音樂一樣， 人在但靈魂不知道漂到哪裡去了\n身邊有想幫助我的人，但我就像一塊木頭沒有任何反應 一開始聽發現就那麼自然的讓我會心一笑了 漸漸的你們輸出的內容就一點點流進來 像旁敲側擊一樣 我也說不清楚是什麼準確的東西 感覺原本很僵固的那一塊開始悄悄地鬆動了\n上次有提到真的讓我有感觸 開始思考我自己到底需要得到什麼幫助的是第12集 我之前的狀態大概就是知道自己需要幫助但說不清楚想要什麼 確實就是抱著去看醫生希望問題就能得到解決 也有一點賭氣不想好起來，可以說是耗著頂多讓我能勉強維持繼續工作不要放棄 那一集你們很真實的表達了你們所能做的，還有從你們角度看到的東西 我才意識到當時看診的醫師碰到我應該覺得很無力吧\n後來開始聽裘我呀、有聲書評、一天聽一點到最近的心理小學堂 很喜歡聽你們用心製作分享的內容 謝謝你們(希望能夠幫我轉達這份感謝給怡璇、媗甯等所有用心付出製作這些內容的你們)\n決定是否要走進實體課程我想了很久 像你們問我對這堂課有什麼期望 我一開始回答沒有其實是因為更清楚地知道你們扮演的角色 是陪伴每一個來到裡的學員，用你們的專業帶我們用不同角度抑或去看見各自心裡面埋在更深的東西 主要是需要願意把自己打開才有可能在這門課程有所收穫。\n我可能有滿多議題要解決，不是這門課都能得到解答，也或許不是所有東西都需要答案 從上一次面談應該可以感覺到我不是一個有自信的人 我知道怎麼做一個乖女兒、好學生、好員工(別人期待的樣子) 但我不太會照顧到自己的需要 不會肯定自己、沒有辦法給自己力量、好好的跟自己相處。 所以這應該是我現階段最需要的 好好的把自己搞清楚才有餘力去照顧到其他關係。\n選擇踏進來的我應該是準備好了 我知道會是一段痛苦的過程 我當下組織語言的能力比較弱，不知道怎麼回答就會卡住 你們可能會常常碰到我的沉默、或是一個含糊的回答 有時候是找不到精準描述的詞彙、或是沒有想過這種可能 給我選擇或是比較明確的例子，可能可以引導我表達出我當下更準確的想法 或是留給我一些時間思考，你們的建議或提問我都會很認真的在聽 如果沒有馬上的反饋通常表示我需要回去消化一下，對我來說用寫的應該可以表達得更清楚\n期待你們持續推出的內容以及未來課程，謝謝你們！\n天韻\n","permalink":"https://tientiensmile.github.io/posts/life/20220227/","summary":"Dear 嘉玲、凱宇老師：）\n上次課前談話沒說出口的，想要謝謝你們！ 雖然是去年9月左右才認識啟點 但感覺你們的聲音已經陪伴我好一段時間 從敲門這個節目開始覺得很幸運能認識你們 上次問我是哪一集觸動到我 仔細回想，當時是從搜尋看到的 我的習慣像看影集一樣，不是別人推薦的不管有沒有連貫我都會從第一集開始 主要是被輕鬆有趣的談話吸引吧 小到開場偶爾的卡詞都讓我覺得特別真實 我當時的情緒狀態特別低落也特別封閉什麼聲音都聽不進進去 打開會追的影集就像在播背景音樂一樣， 人在但靈魂不知道漂到哪裡去了\n身邊有想幫助我的人，但我就像一塊木頭沒有任何反應 一開始聽發現就那麼自然的讓我會心一笑了 漸漸的你們輸出的內容就一點點流進來 像旁敲側擊一樣 我也說不清楚是什麼準確的東西 感覺原本很僵固的那一塊開始悄悄地鬆動了\n上次有提到真的讓我有感觸 開始思考我自己到底需要得到什麼幫助的是第12集 我之前的狀態大概就是知道自己需要幫助但說不清楚想要什麼 確實就是抱著去看醫生希望問題就能得到解決 也有一點賭氣不想好起來，可以說是耗著頂多讓我能勉強維持繼續工作不要放棄 那一集你們很真實的表達了你們所能做的，還有從你們角度看到的東西 我才意識到當時看診的醫師碰到我應該覺得很無力吧\n後來開始聽裘我呀、有聲書評、一天聽一點到最近的心理小學堂 很喜歡聽你們用心製作分享的內容 謝謝你們(希望能夠幫我轉達這份感謝給怡璇、媗甯等所有用心付出製作這些內容的你們)\n決定是否要走進實體課程我想了很久 像你們問我對這堂課有什麼期望 我一開始回答沒有其實是因為更清楚地知道你們扮演的角色 是陪伴每一個來到裡的學員，用你們的專業帶我們用不同角度抑或去看見各自心裡面埋在更深的東西 主要是需要願意把自己打開才有可能在這門課程有所收穫。\n我可能有滿多議題要解決，不是這門課都能得到解答，也或許不是所有東西都需要答案 從上一次面談應該可以感覺到我不是一個有自信的人 我知道怎麼做一個乖女兒、好學生、好員工(別人期待的樣子) 但我不太會照顧到自己的需要 不會肯定自己、沒有辦法給自己力量、好好的跟自己相處。 所以這應該是我現階段最需要的 好好的把自己搞清楚才有餘力去照顧到其他關係。\n選擇踏進來的我應該是準備好了 我知道會是一段痛苦的過程 我當下組織語言的能力比較弱，不知道怎麼回答就會卡住 你們可能會常常碰到我的沉默、或是一個含糊的回答 有時候是找不到精準描述的詞彙、或是沒有想過這種可能 給我選擇或是比較明確的例子，可能可以引導我表達出我當下更準確的想法 或是留給我一些時間思考，你們的建議或提問我都會很認真的在聽 如果沒有馬上的反饋通常表示我需要回去消化一下，對我來說用寫的應該可以表達得更清楚\n期待你們持續推出的內容以及未來課程，謝謝你們！\n天韻","title":"20220227"},{"content":"Combination Operators  將多個 Observable 組合成單個 Observable 運算符。  startWith  開始從某個 Observable 發出元素之前發出指定的元素序列。   每個連續的 startWith 元素都將在前一個 startWith 元素之前添加。\n let disposeBag = DisposeBag() Observable.of(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;) .startWith(\u0026#34;1\u0026#34;) .startWith(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;) .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) 印出結果\na b c 1 A B C D merge zip combineLatest switchLatest withLatestFrom  ","permalink":"https://tientiensmile.github.io/posts/rxswift/rxswift_combination_operators/","summary":"Combination Operators  將多個 Observable 組合成單個 Observable 運算符。  startWith  開始從某個 Observable 發出元素之前發出指定的元素序列。   每個連續的 startWith 元素都將在前一個 startWith 元素之前添加。\n let disposeBag = DisposeBag() Observable.of(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;) .startWith(\u0026#34;1\u0026#34;) .startWith(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;) .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) 印出結果\na b c 1 A B C D merge zip combineLatest switchLatest withLatestFrom  ","title":"RxSwift - Combination Operators"},{"content":"take  從 Observable 中發出頭 n 個元素，忽略後面的元素直到序列結束。   let disposeBag = DisposeBag() Observable.of(\u0026#34;🐱\u0026#34;, \u0026#34;🐰\u0026#34;, \u0026#34;🐶\u0026#34;, \u0026#34;🐸\u0026#34;, \u0026#34;🐷\u0026#34;, \u0026#34;🐵\u0026#34;) .take(3) .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) 印出結果\n🐱 🐰 🐶 distinctUntilChanged  阻止 Observable 發出相同的元素。如果後一個元素和前一個元素相同，將不會發出來，若後一個元素和前一個元素不同才會被發出來。   let disposeBag = DisposeBag() Observable.of(\u0026quot;🐱\u0026quot;, \u0026quot;🐷\u0026quot;, \u0026quot;🐱\u0026quot;, \u0026quot;🐱\u0026quot;, \u0026quot;🐱\u0026quot;, \u0026quot;🐵\u0026quot;, \u0026quot;🐱\u0026quot;) .distinctUntilChanged() .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) 印出結果\n🐱 🐷 🐱 🐵 🐱 ","permalink":"https://tientiensmile.github.io/posts/rxswift/rxswift_operators_2/","summary":"take  從 Observable 中發出頭 n 個元素，忽略後面的元素直到序列結束。   let disposeBag = DisposeBag() Observable.of(\u0026#34;🐱\u0026#34;, \u0026#34;🐰\u0026#34;, \u0026#34;🐶\u0026#34;, \u0026#34;🐸\u0026#34;, \u0026#34;🐷\u0026#34;, \u0026#34;🐵\u0026#34;) .take(3) .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) 印出結果\n🐱 🐰 🐶 distinctUntilChanged  阻止 Observable 發出相同的元素。如果後一個元素和前一個元素相同，將不會發出來，若後一個元素和前一個元素不同才會被發出來。   let disposeBag = DisposeBag() Observable.of(\u0026quot;🐱\u0026quot;, \u0026quot;🐷\u0026quot;, \u0026quot;🐱\u0026quot;, \u0026quot;🐱\u0026quot;, \u0026quot;🐱\u0026quot;, \u0026quot;🐵\u0026quot;, \u0026quot;🐱\u0026quot;) .distinctUntilChanged() .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) 印出結果\n🐱 🐷 🐱 🐵 🐱 ","title":"RxSwift - take、distinctUntilChanged"},{"content":"combineLatest  將多個 Observables 中最新的元素透過一個函數組合起來，然後將結果發出來。  let disposeBag = DisposeBag() let first = PublishSubject\u0026lt;String\u0026gt;() let second = PublishSubject\u0026lt;String\u0026gt;() Observable.combineLatest(first, second) { $0 + $1 } .dubscribe(onNext: { print($0) }) .disposed(by: disposeBag) first.onNext(\u0026#34;1\u0026#34;) second.onNext(\u0026#34;A\u0026#34;) first.onNext(\u0026#34;2\u0026#34;) second.onNext(\u0026#34;B\u0026#34;) second.onNext(\u0026#34;C\u0026#34;) second.onNext(\u0026#34;D\u0026#34;) first.onNext(\u0026#34;3\u0026#34;) first.onNext(\u0026#34;4\u0026#34;) 印出結果\n1A 2A 2B 2C 2D 3D 4D skip  跳過 Observable 中頭 n 個元素  do  使用 do 來監聽事件的生命週期，它會在每一次事件發送前被調用。 它和 subscribe 一樣，可以通過不同的閉包回調不同類型的事件。 如：do(onNext: ) 在 subscribe(onNext:) 前，do(onCompleted:) 在 subscribe(onCompleted:) 前調用。  let observable = Observable.of(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) observable .do(onNext: { element in print(\u0026#34;Intercepted Next：\u0026#34;, element) }, onError: { error in print(\u0026#34;Intercepted Error：\u0026#34;, error) }, onCompleted: { print(\u0026#34;Intercepted Completed\u0026#34;) }, onDispose: { print(\u0026#34;Intercepted Disposed\u0026#34;) }) .subscribe(onNext: { element in print(element) }, onError: { error in print(error) }, onCompleted: { print(\u0026#34;completed\u0026#34;) }, onDisposed: { print(\u0026#34;disposed\u0026#34;) }) 印出結果\nIntercepted Next： A A Intercepted Next： B B Intercepted Next： C C Intercepted Completed completed disposed Intercepted Disposed ","permalink":"https://tientiensmile.github.io/posts/rxswift/rxswift_operators_1/","summary":"combineLatest  將多個 Observables 中最新的元素透過一個函數組合起來，然後將結果發出來。  let disposeBag = DisposeBag() let first = PublishSubject\u0026lt;String\u0026gt;() let second = PublishSubject\u0026lt;String\u0026gt;() Observable.combineLatest(first, second) { $0 + $1 } .dubscribe(onNext: { print($0) }) .disposed(by: disposeBag) first.onNext(\u0026#34;1\u0026#34;) second.onNext(\u0026#34;A\u0026#34;) first.onNext(\u0026#34;2\u0026#34;) second.onNext(\u0026#34;B\u0026#34;) second.onNext(\u0026#34;C\u0026#34;) second.onNext(\u0026#34;D\u0026#34;) first.onNext(\u0026#34;3\u0026#34;) first.onNext(\u0026#34;4\u0026#34;) 印出結果\n1A 2A 2B 2C 2D 3D 4D skip  跳過 Observable 中頭 n 個元素  do  使用 do 來監聽事件的生命週期，它會在每一次事件發送前被調用。 它和 subscribe 一樣，可以通過不同的閉包回調不同類型的事件。 如：do(onNext: ) 在 subscribe(onNext:) 前，do(onCompleted:) 在 subscribe(onCompleted:) 前調用。  let observable = Observable.","title":"RxSwift - combineLatest、skip、do"},{"content":"ObservableObject 和 @ObservedObject  ObservableObject 是一個 protocol，要求實現協議的類型為 class，有一個需要實作的屬性 objectWillChange。 當數據將要發生改變時，這個屬性用來向外進行「廣播」，它的訂閱者(一般是 View 相關的邏輯)在收到通知後，對 View 進行刷新。 創建遵從 ObservableObject 協議的類別後，實際在 View 裡使用需要將此物件宣告為 @ObservedObject。  範例：點擊按鈕擲骰子  使用 PassthroughSubject 中 send() 方法通知事件將要發生。 PassthroughSubject 於 Combine 框架中，將於後續介紹。\n  ContentView 中 model 為 reference type，使用 @ObservedObject 將它和 ContentView 關聯起來。當 model 中的屬性 diceState 將要改變，objectWillChange 就會發出事件，使得 body 被調用進行UI刷新。  struct ContentView: View { @ObservedObject private var model = DiceModel() var body: some View { CounterButton(diceState: $model.diceState) } } class DiceModel: ObservableObject { let objectWillChange = PassthroughSubject\u0026lt;Void, Never\u0026gt;() var diceState: DiceState = .one { willSet { objectWillChange.send() } } } enum DiceState: Int { case one = 1 case two = 2 case three = 3 case four = 4 case five = 5 case six = 6 } @Published  在 ObservableObject 中，每個對介面可能產生影響的屬性都可以如 diceState 的 willSet 那樣，手動調用 objectWillChange.send()。若 model 有很多屬性逐一添加 willSet 很麻煩且重複。 簡化寫法為：省略宣告 objectWillChange，並將屬性標記為 Published。  class DiceModel: ObservableObject { @Published var diceState: DiceState = .one } @EnvironmentObject  當多個 View 需要訪問到同一個 model，使用 @ObservedObject 需要大量的屬性傳遞，改用 @EnvironmentObject 可以便捷的達到大批量共享。 跟單例很像，只要在 View 層級以上，不論在哪裡都可以訪問到這個環境對象。  struct ContentView: View { @EnvironmentObject var model: DiceModel var body: some View { CounterButton() } } struct CounterButton: View { @EnvironmentObject var model: DiceModel var body: some View { Button { let value = Int.random(in: 1...6) let dice = DiceState(rawValue: value) model.diceState = dice ?? .one } label: { Circle() .frame(width: 150, height: 150, alignment: .center) .foregroundColor(.blue) .overlay { Text(\u0026#34;\\(model.diceState.rawValue)\u0026#34;) .font(.system(size:72, weight: .bold)) .foregroundColor(.white) } } } } 在創建 ContentView 的地方注入 environmentObject\n@main struct SwiftUIDemoApp: App { var body: some Scene { WindowGroup { ContentView().environmentObject(DiceModel()) } } } 總結  @State 和 @Binding 提供 View 內部的狀態儲存，應是簡單的 value type 標記為 private 僅供內部使用。 ObservableObject中@ObservedObject和 @EnvironmentObject 則是針對跨越 View 層級的狀態共享，可以處理較複雜的數據類型，為 reference type。需要在數據變化時向外發送通知，來觸發介面刷新。 建議一開始可以先選擇使用 @ObservedObject，若發現狀態可以被限制在同一個 View 層級，則改用 @State；若狀態需要大量共享，則改用 @EnvironmentObject  ","permalink":"https://tientiensmile.github.io/posts/swiftui/swiftui_observableobject/","summary":"ObservableObject 和 @ObservedObject  ObservableObject 是一個 protocol，要求實現協議的類型為 class，有一個需要實作的屬性 objectWillChange。 當數據將要發生改變時，這個屬性用來向外進行「廣播」，它的訂閱者(一般是 View 相關的邏輯)在收到通知後，對 View 進行刷新。 創建遵從 ObservableObject 協議的類別後，實際在 View 裡使用需要將此物件宣告為 @ObservedObject。  範例：點擊按鈕擲骰子  使用 PassthroughSubject 中 send() 方法通知事件將要發生。 PassthroughSubject 於 Combine 框架中，將於後續介紹。\n  ContentView 中 model 為 reference type，使用 @ObservedObject 將它和 ContentView 關聯起來。當 model 中的屬性 diceState 將要改變，objectWillChange 就會發出事件，使得 body 被調用進行UI刷新。  struct ContentView: View { @ObservedObject private var model = DiceModel() var body: some View { CounterButton(diceState: $model.diceState) } } class DiceModel: ObservableObject { let objectWillChange = PassthroughSubject\u0026lt;Void, Never\u0026gt;() var diceState: DiceState = .","title":"SwiftUI - ObservableObject"},{"content":"屬性包裝、投射屬性  由 @ 修飾的屬性稱為屬性包裝(Property Wrapper)。 @State、@Binding、@ObjectBinding、@EnvironmentObject都是 @propertyWrapper 修飾的 struct。 對一個由 @ 修飾的屬性，在它前面使用 $ 取得的值，被稱為投射屬性(Projection Property)。 並不是所有的 @ 屬性都提供 $ 的投射訪問方式。  @State  @State 修飾的屬性會被自動轉換為一對 setter 和 getter 對這個屬性進行賦值的操作，它的 body 會被再次調用，進行 View 的刷新。 但由於是 value type ，在不同物件傳遞時透過複製值，因此經過不同層級底層改變並無法更新頂層的值。 訪問 @State 修飾的屬性，所有調用觸發的都是 wrappedValue。 使用 $ 訪問屬性，取得的是 projectedValue ，為一個 Binding 類型的值。  SwiftUI 中 State 定義的關鍵部分\n@propertyWrapper public struct State\u0026lt;Value\u0026gt;: DynamicViewProperty, BindingConvertible { public var value: Value { get nonmutating set } public var wrappedValue: Value { get nonmutating set } public var projectedValue: Binding\u0026lt;Value\u0026gt; { get } init(initialValue value: Value) } 範例：點擊按鈕數字累加點擊次數 struct ContentView: View { @State private var count: Int = 0 var body: some View { Button { self.count += 1 } label: { Circle() .frame(width: 150, height: 150, alignment: .center) .foregroundColor(.blue) .overlay { Text(\u0026#34;\\(count)\u0026#34;) .font(.system(size:72, weight: .bold)) .foregroundColor(.white) } } } } @Binding  和 @State 類似，也是對屬性的修飾，但將 value type 轉換為 reference type。 對 @Binding 修飾的屬性進行賦值，改變的是其參考，因此可以在不同物件傳遞。  範例：同上(將按鈕定義為CounterButton)  CounterButton 中宣告 count 變數以 @Binding 修飾，在 ContentView 以 projectedValue 將 $counter 傳遞至 CounterButton，當點擊按鈕 count 值改變，畫面改變，counter亦跟著改變。   print(counter) 印出結果皆為 1, 2, 3\u0026hellip;\n  若 CounterButton 中宣告 count 變數以 @State 修飾，在 ContentView 以 wrappedValue 將 counter 傳遞至 CounterButton，當點擊按鈕 count 值改變，畫面改變，但 counter 不會跟著改變。   print(counter) 印出結果皆為 0\n struct ContentView: View { @State private var counter: Int = 0 var body: some View { CounterButton(count: $counter) { print(counter) } } } struct CounterButton: View { @Binding var count: Int var body: some View { Button { self.count += 1 } label: { Circle() .frame(width: 150, height: 150, alignment: .center) .foregroundColor(.blue) .overlay { Text(\u0026#34;\\(count)\u0026#34;) .font(.system(size:72, weight: .bold)) .foregroundColor(.white) } } } } ","permalink":"https://tientiensmile.github.io/posts/swiftui/swiftui_stateandbinding/","summary":"屬性包裝、投射屬性  由 @ 修飾的屬性稱為屬性包裝(Property Wrapper)。 @State、@Binding、@ObjectBinding、@EnvironmentObject都是 @propertyWrapper 修飾的 struct。 對一個由 @ 修飾的屬性，在它前面使用 $ 取得的值，被稱為投射屬性(Projection Property)。 並不是所有的 @ 屬性都提供 $ 的投射訪問方式。  @State  @State 修飾的屬性會被自動轉換為一對 setter 和 getter 對這個屬性進行賦值的操作，它的 body 會被再次調用，進行 View 的刷新。 但由於是 value type ，在不同物件傳遞時透過複製值，因此經過不同層級底層改變並無法更新頂層的值。 訪問 @State 修飾的屬性，所有調用觸發的都是 wrappedValue。 使用 $ 訪問屬性，取得的是 projectedValue ，為一個 Binding 類型的值。  SwiftUI 中 State 定義的關鍵部分\n@propertyWrapper public struct State\u0026lt;Value\u0026gt;: DynamicViewProperty, BindingConvertible { public var value: Value { get nonmutating set } public var wrappedValue: Value { get nonmutating set } public var projectedValue: Binding\u0026lt;Value\u0026gt; { get } init(initialValue value: Value) } 範例：點擊按鈕數字累加點擊次數 struct ContentView: View { @State private var count: Int = 0 var body: some View { Button { self.","title":"SwiftUI - 狀態(State)與綁定(Binding)"},{"content":" 適合 SwiftUI 的架構\n Redux 基本概念  App 為一個狀態機，狀態決定用戶介面。 這些狀態(State)都保存在一個 Store 物件中。 View 不能直接操作 State，只能通過發送 Action 的方式間接改變儲存在 Store 中的 State 。 Reducer 接受原有的 State 和發送過來的 Action，生成新的 State。 用新的 State 替換 Store 中原有的狀態，並用新的狀態來驅動更新介面。  Store 應用程式只有一個 Store，用來保存整個應用程式的 State。 可以透過 store.getState() 取得應用程式當前狀態，但不能直接修改。\nAction Action 為一個普通的物件，用來描述應用程式發生的事情，把數據傳遞給 Store 的唯一途徑。\nReducer Reducer.reduce(state: action:)是純函數，具體處理狀態的邏輯。\n 純函數：返回值只由調用時的參數決定，不依賴於任何系統狀態，也不改變其作用域之外的變量狀態的函數。\n struct Reducer { static func reduce(state: State, action: Action) -\u0026gt; State { return state.apply(item: action) } } ","permalink":"https://tientiensmile.github.io/posts/redux_intro/","summary":" 適合 SwiftUI 的架構\n Redux 基本概念  App 為一個狀態機，狀態決定用戶介面。 這些狀態(State)都保存在一個 Store 物件中。 View 不能直接操作 State，只能通過發送 Action 的方式間接改變儲存在 Store 中的 State 。 Reducer 接受原有的 State 和發送過來的 Action，生成新的 State。 用新的 State 替換 Store 中原有的狀態，並用新的狀態來驅動更新介面。  Store 應用程式只有一個 Store，用來保存整個應用程式的 State。 可以透過 store.getState() 取得應用程式當前狀態，但不能直接修改。\nAction Action 為一個普通的物件，用來描述應用程式發生的事情，把數據傳遞給 Store 的唯一途徑。\nReducer Reducer.reduce(state: action:)是純函數，具體處理狀態的邏輯。\n 純函數：返回值只由調用時的參數決定，不依賴於任何系統狀態，也不改變其作用域之外的變量狀態的函數。\n struct Reducer { static func reduce(state: State, action: Action) -\u0026gt; State { return state.apply(item: action) } } ","title":"Redux架構"},{"content":"Subjects 同時是 Observable 也是 Observer\nPublish Subject 訂閱之後才會收到發出的事件。\nlet subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.dispose() /// Issue 3 在dispose之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) let subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.onCompleted() /// Issue 3 在completed之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) completed Behavior Subject 需給定初始值，因爲訂閱它時，會得到初始值或訂閱前最後一個值。\nlet subject = BehaviorSubject(value: \u0026#34;Initial value\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 1\u0026#34;) /// 印出結果 next(Initial value) next(Issue 1) let subject = BehaviorSubject(value: \u0026#34;Initial value\u0026#34;) subject.onNext(\u0026#34;Last Issue\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 1\u0026#34;) /// 印出結果 next(Last Issue) next(Issue 1) Relay Subject 訂閱後可以收到指定數量最新訂閱前發出的事件。\nlet subject = ReplaySubject\u0026lt;String\u0026gt;.create(bufferSize: 2) subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.onNext(\u0026#34;Issue 3\u0026#34;) print(\u0026#34;[Subscription 1]\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 4\u0026#34;) subject.onNext(\u0026#34;Issue 5\u0026#34;) subject.onNext(\u0026#34;Issue 6\u0026#34;) print(\u0026#34;[Subscription 2]\u0026#34;) subject.subscribe { event in print(event) } /// 印出結果 ubscription 1] next(Issue 2) next(Issue 3) next(Issue 4) next(Issue 5) next(Issue 6) [Subscription 2] next(Issue 5) next(Issue 6) Variables  即將廢除由 BehaviorRelay 取代\n 為一個可以儲存值的Behavior Subject，我們可以對其屬性存取值。\nlet variable = Variable(\u0026#34;Initial value\u0026#34;) variable.value = \u0026#34;Hello world\u0026#34; variable.asObservable().subscribe { print($0) } /// 印出結果 next(Hello world) 訂閱一個字串陣列，當改變陣列內容就會收到事件得到當前陣列的內容。\nlet variable = Variable([String]()) variable.value.append(\u0026#34;Item 1\u0026#34;) variable.asObservable().subscribe { print($0) } variable.value.append(\u0026#34;Item 2\u0026#34;) /// 印出結果 next([\u0026#34;Item 1\u0026#34;]) next([\u0026#34;Item 1\u0026#34;, \u0026#34;Item 2\u0026#34;]) BehaviorRelay  需要 pod 'RxCocoa'\n  value 屬性限制為 get-only 更新值使用 accept()  let replay = BehaviorRelay(value: \u0026#34;Item 1\u0026#34;) replay.accept(\u0026#34;Hello world\u0026#34;) replay.asObservable() .subscribe { print($0) } /// 印出結果 next(Hello world) 值的更新為 accept 收到的值，若要累加需先從屬性中取出原本的值。\nlet replay = BehaviorRelay(value: [\u0026#34;Item 1\u0026#34;]) replay.accept([\u0026#34;Item 2\u0026#34;]) replay.asObservable() .subscribe { print($0) } replay.accept(replay.value + [\u0026#34;Item 3\u0026#34;]) /// 印出結果 next([\u0026#34;Item 2\u0026#34;]) next([\u0026#34;Item 2\u0026#34;, \u0026#34;Item 3\u0026#34;]) ","permalink":"https://tientiensmile.github.io/posts/rxswift/rxswift_subjects/","summary":"Subjects 同時是 Observable 也是 Observer\nPublish Subject 訂閱之後才會收到發出的事件。\nlet subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.dispose() /// Issue 3 在dispose之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) let subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.onCompleted() /// Issue 3 在completed之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) completed Behavior Subject 需給定初始值，因爲訂閱它時，會得到初始值或訂閱前最後一個值。","title":"RxSwift - Subjects"},{"content":"每一個 Observable 就只是一個序列(Sequence)而已。\nsubscribe 一個 observable，以訂閱UISlider為例，當滑動UISlider時值改變就會通知訂閱(subscride)的人。\n建立Observables 建立一個只有一個 element，值為1的observable\nlet observable = Observable.just(1) 建立一個三個element，型別為int的observable\nlet observable2 = Observable.of(1,2,3) 建立一個只有一個element，為int陣列的observable\nlet observable3 = Observable.of([1,2,3]) 用from遍歷陣列中每一個element，相當於observable2\nlet observable4 = Observable.from([1,2,3]) 建立Subscriptions observable4.subscribe { event in print(event) } /// 印出結果 next(1) next(2) next(3) completed /// 取得Observable中的值 observable4.subscribe { event in if let element = event.element { print(element) } } /// 較簡易取得element的方法 observable4.subscribe(onNext: { element in print(element) }) /// 印出結果 1 2 3 observable3.subscribe { event in print(event) } /// 印出結果 next([1, 2, 3]) completed 取得Observable中的值\nobservable3.subscribe(onNext: { element in print(element) }) /// 印出結果 [1, 2, 3] Event - 事件 enum Event\u0026lt;Element\u0026gt; { case next(Element) case error(Swift.Error) case completed }  next：序列產生一個新的元素 completed：序列的所有元素都成功產生，整個序列已經完成 error：創建序列時產生了一個錯誤，導致序列終止  Disposing  當 Observable 有被訂閱(subscribe)，表示建立了訂閱者一直在觀察這個序列，因此當序列完成需要適當的 dispose 這些 subscriptions，否則會產生memory leak。\n 針對單個訂閱做dispose\nlet subscription4 = observable4.subscribe(onNext: { element in print(element) }) subscription4.dispose() 使用disposeBag，當序列完成自動進行dispose\nlet disposeBag = DisposeBag() Observable.of(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .subscribe { print($0) }.disposed(by: disposeBag) 另一種創建序列及訂閱的方法  調用 Observable.create 創建序列，在構建函數裡描述元素的產生過程。\n 當一個序列completed或是出現error就不會再觸發後續的事件\nObservable\u0026lt;String\u0026gt;.create { observer in observer.onNext(\u0026#34;A\u0026#34;) observer.onCompleted() observer.onNext(\u0026#34;B\u0026#34;) observer.onNext(\u0026#34;C\u0026#34;) return Disposables.create() }.subscribe { print($0) } onError: { print($0) } onCompleted: { print(\u0026#34;Completed\u0026#34;) } onDisposed: { print(\u0026#34;Disposed\u0026#34;) }.disposed(by: disposeBag) /// 印出結果 A Completed Disposed ","permalink":"https://tientiensmile.github.io/posts/rxswift/rxswift_observable/","summary":"每一個 Observable 就只是一個序列(Sequence)而已。\nsubscribe 一個 observable，以訂閱UISlider為例，當滑動UISlider時值改變就會通知訂閱(subscride)的人。\n建立Observables 建立一個只有一個 element，值為1的observable\nlet observable = Observable.just(1) 建立一個三個element，型別為int的observable\nlet observable2 = Observable.of(1,2,3) 建立一個只有一個element，為int陣列的observable\nlet observable3 = Observable.of([1,2,3]) 用from遍歷陣列中每一個element，相當於observable2\nlet observable4 = Observable.from([1,2,3]) 建立Subscriptions observable4.subscribe { event in print(event) } /// 印出結果 next(1) next(2) next(3) completed /// 取得Observable中的值 observable4.subscribe { event in if let element = event.element { print(element) } } /// 較簡易取得element的方法 observable4.subscribe(onNext: { element in print(element) }) /// 印出結果 1 2 3 observable3.subscribe { event in print(event) } /// 印出結果 next([1, 2, 3]) completed 取得Observable中的值","title":"RxSwift - Observable 可監聽序列"},{"content":"觀察者是用來監聽序列，當收到事件作出響應。\n建立觀察者 對一個 Observable 進行 subscribe。事件發生時於後面的 onNext、onError、onCompleted作出響應。\ntap.subscribe(onNext: { [weak self] in self?.showAlert() }, onError: { error in print(\u0026#34;發生錯誤： \\(error.localizedDescription)\u0026#34;) }, onCompleted: { print(\u0026#34;完成任務\u0026#34;) }) AnyObserver AnyObserver 可以用來描述任意一種觀察者。\n範例：印出網路請求結果\nURLSession.shared.rx.data(request: URLRequest(url: url)) .subscribe(onNext: { data in print(\u0026#34;Data Task Success with count: \\(data.count)\u0026#34;) }, onError: { error in print(\u0026#34;Data Task Error: \\(error)\u0026#34;) }) .disposed(by: disposeBag) 可以改寫為\nlet observer: AnyObserver\u0026lt;Data\u0026gt; = AnyObserver { (event) in switch event { case .next(let data): print(\u0026#34;Data Task Success with count: \\(data.count)\u0026#34;) case .error(let error): print(\u0026#34;Data Task Error: \\(error)\u0026#34;) default: break } } URLSession.shared.rx.data(request: URLRequest(url: url)) .subscribe(observer) .disposed(by: disposeBag) Binder  Binder 不會處理錯誤事件 確保綁定都是在給定的 Scheduler 上執行 (默認為 MainScheduler)  範例： 这个观察者是一个 UI 观察者，所以它在响应事件时，只会处理 next 事件，并且更新 UI 的操作需要在主线程上执行。\nlet observer: AnyObserver\u0026lt;Bool\u0026gt; = AnyObserver { [weak self] (event) in switch event { case .next(let isHidden): self?.usernameValidOutlet.isHidden = isHidden default: break } } usernameValid .bind(to: observer) .disposed(by: disposeBag) ","permalink":"https://tientiensmile.github.io/posts/rxswift/rxswift_observer/","summary":"觀察者是用來監聽序列，當收到事件作出響應。\n建立觀察者 對一個 Observable 進行 subscribe。事件發生時於後面的 onNext、onError、onCompleted作出響應。\ntap.subscribe(onNext: { [weak self] in self?.showAlert() }, onError: { error in print(\u0026#34;發生錯誤： \\(error.localizedDescription)\u0026#34;) }, onCompleted: { print(\u0026#34;完成任務\u0026#34;) }) AnyObserver AnyObserver 可以用來描述任意一種觀察者。\n範例：印出網路請求結果\nURLSession.shared.rx.data(request: URLRequest(url: url)) .subscribe(onNext: { data in print(\u0026#34;Data Task Success with count: \\(data.count)\u0026#34;) }, onError: { error in print(\u0026#34;Data Task Error: \\(error)\u0026#34;) }) .disposed(by: disposeBag) 可以改寫為\nlet observer: AnyObserver\u0026lt;Data\u0026gt; = AnyObserver { (event) in switch event { case .next(let data): print(\u0026#34;Data Task Success with count: \\(data.","title":"RxSwift - Observer 觀察者"}]