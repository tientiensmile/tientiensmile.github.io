[{"content":"每一個 Observable 就只是一個序列(Sequence)而已。\nsubscribe 一個 observable，以訂閱UISlider為例，當滑動UISlider時值改變就會通知訂閱(subscride)的人。\n建立Observables 建立一個只有一個 element，值為1的observable\nlet observable = Observable.just(1) 建立一個三個element，型別為int的observable\nlet observable2 = Observable.of(1,2,3) 建立一個只有一個element，為int陣列的observable\nlet observable3 = Observable.of([1,2,3]) 用from遍歷陣列中每一個element，相當於observable2\nlet observable4 = Observable.from([1,2,3]) 建立Subscriptions observable4.subscribe { event in print(event) } /// 印出結果 next(1) next(2) next(3) completed /// 取得Observable中的值 observable4.subscribe { event in if let element = event.element { print(element) } } /// 較簡易取得element的方法 observable4.subscribe(onNext: { element in print(element) }) /// 印出結果 1 2 3 observable3.subscribe { event in print(event) } /// 印出結果 next([1, 2, 3]) completed 取得Observable中的值\nobservable3.subscribe(onNext: { element in print(element) }) /// 印出結果 [1, 2, 3] Event - 事件 enum Event\u0026lt;Element\u0026gt; { case next(Element) case error(Swift.Error) case completed }  next：序列產生一個新的元素 completed：序列的所有元素都成功產生，整個序列已經完成 error：創建序列時產生了一個錯誤，導致序列終止  Disposing  當 Observable 有被訂閱(subscribe)，表示建立了訂閱者一直在觀察這個序列，因此當序列完成需要適當的 dispose 這些 subscriptions，否則會產生memory leak。\n 針對單個訂閱做dispose\nlet subscription4 = observable4.subscribe(onNext: { element in print(element) }) subscription4.dispose() 使用disposeBag，當序列完成自動進行dispose\nlet disposeBag = DisposeBag() Observable.of(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .subscribe { print($0) }.disposed(by: disposeBag) 另一種創建序列及訂閱的方法  調用 Observable.create 創建序列，在構建函數裡描述元素的產生過程。\n 當一個序列completed或是出現error就不會再觸發後續的事件\nObservable\u0026lt;String\u0026gt;.create { observer in observer.onNext(\u0026#34;A\u0026#34;) observer.onCompleted() observer.onNext(\u0026#34;B\u0026#34;) observer.onNext(\u0026#34;C\u0026#34;) return Disposables.create() }.subscribe { print($0) } onError: { print($0) } onCompleted: { print(\u0026#34;Completed\u0026#34;) } onDisposed: { print(\u0026#34;Disposed\u0026#34;) }.disposed(by: disposeBag) /// 印出結果 A Completed Disposed ","permalink":"https://tientiensmile.github.io/posts/observable/","summary":"每一個 Observable 就只是一個序列(Sequence)而已。\nsubscribe 一個 observable，以訂閱UISlider為例，當滑動UISlider時值改變就會通知訂閱(subscride)的人。\n建立Observables 建立一個只有一個 element，值為1的observable\nlet observable = Observable.just(1) 建立一個三個element，型別為int的observable\nlet observable2 = Observable.of(1,2,3) 建立一個只有一個element，為int陣列的observable\nlet observable3 = Observable.of([1,2,3]) 用from遍歷陣列中每一個element，相當於observable2\nlet observable4 = Observable.from([1,2,3]) 建立Subscriptions observable4.subscribe { event in print(event) } /// 印出結果 next(1) next(2) next(3) completed /// 取得Observable中的值 observable4.subscribe { event in if let element = event.element { print(element) } } /// 較簡易取得element的方法 observable4.subscribe(onNext: { element in print(element) }) /// 印出結果 1 2 3 observable3.subscribe { event in print(event) } /// 印出結果 next([1, 2, 3]) completed 取得Observable中的值","title":"Observable"},{"content":"Subjects 同時是 Observable 也是 Observer\nPublish Subject 訂閱之後才會收到發出的事件。\nlet subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.dispose() /// Issue 3 在dispose之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) let subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.onCompleted() /// Issue 3 在completed之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) completed Behavior Subject 需給定初始值，因爲訂閱它時，會得到初始值或訂閱前最後一個值。\nlet subject = BehaviorSubject(value: \u0026#34;Initial value\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 1\u0026#34;) /// 印出結果 next(Initial value) next(Issue 1) let subject = BehaviorSubject(value: \u0026#34;Initial value\u0026#34;) subject.onNext(\u0026#34;Last Issue\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 1\u0026#34;) /// 印出結果 next(Last Issue) next(Issue 1) Relay Subject 訂閱後可以收到指定數量最新訂閱前發出的事件。\nlet subject = ReplaySubject\u0026lt;String\u0026gt;.create(bufferSize: 2) subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.onNext(\u0026#34;Issue 3\u0026#34;) print(\u0026#34;[Subscription 1]\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 4\u0026#34;) subject.onNext(\u0026#34;Issue 5\u0026#34;) subject.onNext(\u0026#34;Issue 6\u0026#34;) print(\u0026#34;[Subscription 2]\u0026#34;) subject.subscribe { event in print(event) } /// 印出結果 ubscription 1] next(Issue 2) next(Issue 3) next(Issue 4) next(Issue 5) next(Issue 6) [Subscription 2] next(Issue 5) next(Issue 6) Variables  即將廢除由 BehaviorRelay 取代\n 為一個可以儲存值的Behavior Subject，我們可以對其屬性存取值。\nlet variable = Variable(\u0026#34;Initial value\u0026#34;) variable.value = \u0026#34;Hello world\u0026#34; variable.asObservable().subscribe { print($0) } /// 印出結果 next(Hello world) 訂閱一個字串陣列，當改變陣列內容就會收到事件得到當前陣列的內容。\nlet variable = Variable([String]()) variable.value.append(\u0026#34;Item 1\u0026#34;) variable.asObservable().subscribe { print($0) } variable.value.append(\u0026#34;Item 2\u0026#34;) /// 印出結果 next([\u0026#34;Item 1\u0026#34;]) next([\u0026#34;Item 1\u0026#34;, \u0026#34;Item 2\u0026#34;]) BehaviorRelay  需要 pod 'RxCocoa'\n  value 屬性限制為 get-only 更新值使用 accept()  let replay = BehaviorRelay(value: \u0026#34;Item 1\u0026#34;) replay.accept(\u0026#34;Hello world\u0026#34;) replay.asObservable() .subscribe { print($0) } /// 印出結果 next(Hello world) 值的更新為 accept 收到的值，若要累加需先從屬性中取出原本的值。\nlet replay = BehaviorRelay(value: [\u0026#34;Item 1\u0026#34;]) replay.accept([\u0026#34;Item 2\u0026#34;]) replay.asObservable() .subscribe { print($0) } replay.accept(replay.value + [\u0026#34;Item 3\u0026#34;]) /// 印出結果 next([\u0026#34;Item 2\u0026#34;]) next([\u0026#34;Item 2\u0026#34;, \u0026#34;Item 3\u0026#34;]) ","permalink":"https://tientiensmile.github.io/posts/subjects/","summary":"Subjects 同時是 Observable 也是 Observer\nPublish Subject 訂閱之後才會收到發出的事件。\nlet subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.dispose() /// Issue 3 在dispose之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) let subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.onCompleted() /// Issue 3 在completed之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) completed Behavior Subject 需給定初始值，因爲訂閱它時，會得到初始值或訂閱前最後一個值。","title":"Subjects"}]