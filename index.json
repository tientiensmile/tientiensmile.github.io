[{"content":"ObservableObject 和 @ObservedObject  ObservableObject 是一個 protocol，要求實現協議的類型為 class，有一個需要實作的屬性 objectWillChange。 當數據將要發生改變時，這個屬性用來向外進行「廣播」，它的訂閱者(一般是 View 相關的邏輯)在收到通知後，對 View 進行刷新。 創建遵從 ObservableObject 協議的類別後，實際在 View 裡使用需要將此物件宣告為 @ObservedObject。  範例：點擊按鈕擲骰子  使用 PassthroughSubject 中 send() 方法通知事件將要發生。 PassthroughSubject 於 Combine 框架中，將於後續介紹。\n  ContentView 中 model 為 reference type，使用 @ObservedObject 將它和 ContentView 關聯起來。當 model 中的屬性 diceState 將要改變，objectWillChange 就會發出事件，使得 body 被調用進行UI刷新。  struct ContentView: View { @ObservedObject private var model = DiceModel() var body: some View { CounterButton(diceState: $model.diceState) } } class DiceModel: ObservableObject { let objectWillChange = PassthroughSubject\u0026lt;Void, Never\u0026gt;() var diceState: DiceState = .one { willSet { objectWillChange.send() } } } enum DiceState: Int { case one = 1 case two = 2 case three = 3 case four = 4 case five = 5 case six = 6 } @Published  在 ObservableObject 中，每個對介面可能產生影響的屬性都可以如 diceState 的 willSet 那樣，手動調用 objectWillChange.send()。若 model 有很多屬性逐一添加 willSet 很麻煩且重複。 簡化寫法為：省略宣告 objectWillChange，並將屬性標記為 Published。  class DiceModel: ObservableObject { @Published var diceState: DiceState = .one } @EnvironmentObject  當多個 View 需要訪問到同一個 model，使用 @ObservedObject 需要大量的屬性傳遞，改用 @EnvironmentObject 可以便捷的達到大批量共享。 跟單例很像，只要在 View 層級以上，不論在哪裡都可以訪問到這個環境對象。  struct ContentView: View { @EnvironmentObject var model: DiceModel var body: some View { CounterButton() } } struct CounterButton: View { @EnvironmentObject var model: DiceModel var body: some View { Button { let value = Int.random(in: 1...6) let dice = DiceState(rawValue: value) model.diceState = dice ?? .one } label: { Circle() .frame(width: 150, height: 150, alignment: .center) .foregroundColor(.blue) .overlay { Text(\u0026#34;\\(model.diceState.rawValue)\u0026#34;) .font(.system(size:72, weight: .bold)) .foregroundColor(.white) } } } } 在創建 ContentView 的地方注入 environmentObject\n@main struct SwiftUIDemoApp: App { var body: some Scene { WindowGroup { ContentView().environmentObject(DiceModel()) } } } 總結  @State 和 @Binding 提供 View 內部的狀態儲存，應是簡單的 value type 標記為 private 僅供內部使用。 ObservableObject中@ObservedObject和 @EnvironmentObject 則是針對跨越 View 層級的狀態共享，可以處理較複雜的數據類型，為 reference type。需要在數據變化時向外發送通知，來觸發介面刷新。 建議一開始可以先選擇使用 @ObservedObject，若發現狀態可以被限制在同一個 View 層級，則改用 @State；若狀態需要大量共享，則改用 @EnvironmentObject  ","permalink":"https://tientiensmile.github.io/posts/swiftui_observableobject/","summary":"ObservableObject 和 @ObservedObject  ObservableObject 是一個 protocol，要求實現協議的類型為 class，有一個需要實作的屬性 objectWillChange。 當數據將要發生改變時，這個屬性用來向外進行「廣播」，它的訂閱者(一般是 View 相關的邏輯)在收到通知後，對 View 進行刷新。 創建遵從 ObservableObject 協議的類別後，實際在 View 裡使用需要將此物件宣告為 @ObservedObject。  範例：點擊按鈕擲骰子  使用 PassthroughSubject 中 send() 方法通知事件將要發生。 PassthroughSubject 於 Combine 框架中，將於後續介紹。\n  ContentView 中 model 為 reference type，使用 @ObservedObject 將它和 ContentView 關聯起來。當 model 中的屬性 diceState 將要改變，objectWillChange 就會發出事件，使得 body 被調用進行UI刷新。  struct ContentView: View { @ObservedObject private var model = DiceModel() var body: some View { CounterButton(diceState: $model.diceState) } } class DiceModel: ObservableObject { let objectWillChange = PassthroughSubject\u0026lt;Void, Never\u0026gt;() var diceState: DiceState = .","title":"SwiftUI - ObservableObject"},{"content":"屬性包裝、投射屬性  由 @ 修飾的屬性稱為屬性包裝(Property Wrapper)。 @State、@Binding、@ObjectBinding、@EnvironmentObject都是 @propertyWrapper 修飾的 struct。 對一個由 @ 修飾的屬性，在它前面使用 $ 取得的值，被稱為投射屬性(Projection Property)。 並不是所有的 @ 屬性都提供 $ 的投射訪問方式。  @State  @State 修飾的屬性會被自動轉換為一對 setter 和 getter 對這個屬性進行賦值的操作，它的 body 會被再次調用，進行 View 的刷新。 但由於是 value type ，在不同物件傳遞時透過複製值，因此經過不同層級底層改變並無法更新頂層的值。 訪問 @State 修飾的屬性，所有調用觸發的都是 wrappedValue。 使用 $ 訪問屬性，取得的是 projectedValue ，為一個 Binding 類型的值。  SwiftUI 中 State 定義的關鍵部分\n@propertyWrapper public struct State\u0026lt;Value\u0026gt;: DynamicViewProperty, BindingConvertible { public var value: Value { get nonmutating set } public var wrappedValue: Value { get nonmutating set } public var projectedValue: Binding\u0026lt;Value\u0026gt; { get } init(initialValue value: Value) } 範例：點擊按鈕數字累加點擊次數 struct ContentView: View { @State private var count: Int = 0 var body: some View { Button { self.count += 1 } label: { Circle() .frame(width: 150, height: 150, alignment: .center) .foregroundColor(.blue) .overlay { Text(\u0026#34;\\(count)\u0026#34;) .font(.system(size:72, weight: .bold)) .foregroundColor(.white) } } } } @Binding  和 @State 類似，也是對屬性的修飾，但將 value type 轉換為 reference type。 對 @Binding 修飾的屬性進行賦值，改變的是其參考，因此可以在不同物件傳遞。  範例：同上(將按鈕定義為CounterButton)  CounterButton 中宣告 count 變數以 @Binding 修飾，在 ContentView 以 projectedValue 將 $counter 傳遞至 CounterButton，當點擊按鈕 count 值改變，畫面改變，counter亦跟著改變。   print(counter) 印出結果皆為 1, 2, 3\u0026hellip;\n  若 CounterButton 中宣告 count 變數以 @State 修飾，在 ContentView 以 wrappedValue 將 counter 傳遞至 CounterButton，當點擊按鈕 count 值改變，畫面改變，但 counter 不會跟著改變。   print(counter) 印出結果皆為 0\n struct ContentView: View { @State private var counter: Int = 0 var body: some View { CounterButton(count: $counter) { print(counter) } } } struct CounterButton: View { @Binding var count: Int var body: some View { Button { self.count += 1 } label: { Circle() .frame(width: 150, height: 150, alignment: .center) .foregroundColor(.blue) .overlay { Text(\u0026#34;\\(count)\u0026#34;) .font(.system(size:72, weight: .bold)) .foregroundColor(.white) } } } } ","permalink":"https://tientiensmile.github.io/posts/swiftui_stateandbinding/","summary":"屬性包裝、投射屬性  由 @ 修飾的屬性稱為屬性包裝(Property Wrapper)。 @State、@Binding、@ObjectBinding、@EnvironmentObject都是 @propertyWrapper 修飾的 struct。 對一個由 @ 修飾的屬性，在它前面使用 $ 取得的值，被稱為投射屬性(Projection Property)。 並不是所有的 @ 屬性都提供 $ 的投射訪問方式。  @State  @State 修飾的屬性會被自動轉換為一對 setter 和 getter 對這個屬性進行賦值的操作，它的 body 會被再次調用，進行 View 的刷新。 但由於是 value type ，在不同物件傳遞時透過複製值，因此經過不同層級底層改變並無法更新頂層的值。 訪問 @State 修飾的屬性，所有調用觸發的都是 wrappedValue。 使用 $ 訪問屬性，取得的是 projectedValue ，為一個 Binding 類型的值。  SwiftUI 中 State 定義的關鍵部分\n@propertyWrapper public struct State\u0026lt;Value\u0026gt;: DynamicViewProperty, BindingConvertible { public var value: Value { get nonmutating set } public var wrappedValue: Value { get nonmutating set } public var projectedValue: Binding\u0026lt;Value\u0026gt; { get } init(initialValue value: Value) } 範例：點擊按鈕數字累加點擊次數 struct ContentView: View { @State private var count: Int = 0 var body: some View { Button { self.","title":"SwiftUI - 狀態(State)與綁定(Binding)"},{"content":" 適合 SwiftUI 的架構\n Redux 基本概念  App 為一個狀態機，狀態決定用戶介面。 這些狀態(State)都保存在一個 Store 物件中。 View 不能直接操作 State，只能通過發送 Action 的方式間接改變儲存在 Store 中的 State 。 Reducer 接受原有的 State 和發送過來的 Action，生成新的 State。 用新的 State 替換 Store 中原有的狀態，並用新的狀態來驅動更新介面。  Store 應用程式只有一個 Store，用來保存整個應用程式的 State。 可以透過 store.getState() 取得應用程式當前狀態，但不能直接修改。\nAction Action 為一個普通的物件，用來描述應用程式發生的事情，把數據傳遞給 Store 的唯一途徑。\nReducer Reducer.reduce(state: action:)是純函數，具體處理狀態的邏輯。\n 純函數：返回值只由調用時的參數決定，不依賴於任何系統狀態，也不改變其作用域之外的變量狀態的函數。\n struct Reducer { static func reduce(state: State, action: Action) -\u0026gt; State { return state.apply(item: action) } } ","permalink":"https://tientiensmile.github.io/posts/redux_intro/","summary":" 適合 SwiftUI 的架構\n Redux 基本概念  App 為一個狀態機，狀態決定用戶介面。 這些狀態(State)都保存在一個 Store 物件中。 View 不能直接操作 State，只能通過發送 Action 的方式間接改變儲存在 Store 中的 State 。 Reducer 接受原有的 State 和發送過來的 Action，生成新的 State。 用新的 State 替換 Store 中原有的狀態，並用新的狀態來驅動更新介面。  Store 應用程式只有一個 Store，用來保存整個應用程式的 State。 可以透過 store.getState() 取得應用程式當前狀態，但不能直接修改。\nAction Action 為一個普通的物件，用來描述應用程式發生的事情，把數據傳遞給 Store 的唯一途徑。\nReducer Reducer.reduce(state: action:)是純函數，具體處理狀態的邏輯。\n 純函數：返回值只由調用時的參數決定，不依賴於任何系統狀態，也不改變其作用域之外的變量狀態的函數。\n struct Reducer { static func reduce(state: State, action: Action) -\u0026gt; State { return state.apply(item: action) } } ","title":"Redux架構"},{"content":"Subjects 同時是 Observable 也是 Observer\nPublish Subject 訂閱之後才會收到發出的事件。\nlet subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.dispose() /// Issue 3 在dispose之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) let subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.onCompleted() /// Issue 3 在completed之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) completed Behavior Subject 需給定初始值，因爲訂閱它時，會得到初始值或訂閱前最後一個值。\nlet subject = BehaviorSubject(value: \u0026#34;Initial value\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 1\u0026#34;) /// 印出結果 next(Initial value) next(Issue 1) let subject = BehaviorSubject(value: \u0026#34;Initial value\u0026#34;) subject.onNext(\u0026#34;Last Issue\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 1\u0026#34;) /// 印出結果 next(Last Issue) next(Issue 1) Relay Subject 訂閱後可以收到指定數量最新訂閱前發出的事件。\nlet subject = ReplaySubject\u0026lt;String\u0026gt;.create(bufferSize: 2) subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.onNext(\u0026#34;Issue 3\u0026#34;) print(\u0026#34;[Subscription 1]\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 4\u0026#34;) subject.onNext(\u0026#34;Issue 5\u0026#34;) subject.onNext(\u0026#34;Issue 6\u0026#34;) print(\u0026#34;[Subscription 2]\u0026#34;) subject.subscribe { event in print(event) } /// 印出結果 ubscription 1] next(Issue 2) next(Issue 3) next(Issue 4) next(Issue 5) next(Issue 6) [Subscription 2] next(Issue 5) next(Issue 6) Variables  即將廢除由 BehaviorRelay 取代\n 為一個可以儲存值的Behavior Subject，我們可以對其屬性存取值。\nlet variable = Variable(\u0026#34;Initial value\u0026#34;) variable.value = \u0026#34;Hello world\u0026#34; variable.asObservable().subscribe { print($0) } /// 印出結果 next(Hello world) 訂閱一個字串陣列，當改變陣列內容就會收到事件得到當前陣列的內容。\nlet variable = Variable([String]()) variable.value.append(\u0026#34;Item 1\u0026#34;) variable.asObservable().subscribe { print($0) } variable.value.append(\u0026#34;Item 2\u0026#34;) /// 印出結果 next([\u0026#34;Item 1\u0026#34;]) next([\u0026#34;Item 1\u0026#34;, \u0026#34;Item 2\u0026#34;]) BehaviorRelay  需要 pod 'RxCocoa'\n  value 屬性限制為 get-only 更新值使用 accept()  let replay = BehaviorRelay(value: \u0026#34;Item 1\u0026#34;) replay.accept(\u0026#34;Hello world\u0026#34;) replay.asObservable() .subscribe { print($0) } /// 印出結果 next(Hello world) 值的更新為 accept 收到的值，若要累加需先從屬性中取出原本的值。\nlet replay = BehaviorRelay(value: [\u0026#34;Item 1\u0026#34;]) replay.accept([\u0026#34;Item 2\u0026#34;]) replay.asObservable() .subscribe { print($0) } replay.accept(replay.value + [\u0026#34;Item 3\u0026#34;]) /// 印出結果 next([\u0026#34;Item 2\u0026#34;]) next([\u0026#34;Item 2\u0026#34;, \u0026#34;Item 3\u0026#34;]) ","permalink":"https://tientiensmile.github.io/posts/rxswift/rxswift_subjects/","summary":"Subjects 同時是 Observable 也是 Observer\nPublish Subject 訂閱之後才會收到發出的事件。\nlet subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.dispose() /// Issue 3 在dispose之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) let subject = PublishSubject\u0026lt;String\u0026gt;() /// Issue 1 在訂閱之前收不到 subject.onNext(\u0026#34;Issue 1\u0026#34;) subject.subscribe { event in print(event) } subject.onNext(\u0026#34;Issue 2\u0026#34;) subject.onCompleted() /// Issue 3 在completed之後收不到 subject.onNext(\u0026#34;Issue 3\u0026#34;) /// 印出結果 next(Issue 2) completed Behavior Subject 需給定初始值，因爲訂閱它時，會得到初始值或訂閱前最後一個值。","title":"RxSwift - Subjects"},{"content":"每一個 Observable 就只是一個序列(Sequence)而已。\nsubscribe 一個 observable，以訂閱UISlider為例，當滑動UISlider時值改變就會通知訂閱(subscride)的人。\n建立Observables 建立一個只有一個 element，值為1的observable\nlet observable = Observable.just(1) 建立一個三個element，型別為int的observable\nlet observable2 = Observable.of(1,2,3) 建立一個只有一個element，為int陣列的observable\nlet observable3 = Observable.of([1,2,3]) 用from遍歷陣列中每一個element，相當於observable2\nlet observable4 = Observable.from([1,2,3]) 建立Subscriptions observable4.subscribe { event in print(event) } /// 印出結果 next(1) next(2) next(3) completed /// 取得Observable中的值 observable4.subscribe { event in if let element = event.element { print(element) } } /// 較簡易取得element的方法 observable4.subscribe(onNext: { element in print(element) }) /// 印出結果 1 2 3 observable3.subscribe { event in print(event) } /// 印出結果 next([1, 2, 3]) completed 取得Observable中的值\nobservable3.subscribe(onNext: { element in print(element) }) /// 印出結果 [1, 2, 3] Event - 事件 enum Event\u0026lt;Element\u0026gt; { case next(Element) case error(Swift.Error) case completed }  next：序列產生一個新的元素 completed：序列的所有元素都成功產生，整個序列已經完成 error：創建序列時產生了一個錯誤，導致序列終止  Disposing  當 Observable 有被訂閱(subscribe)，表示建立了訂閱者一直在觀察這個序列，因此當序列完成需要適當的 dispose 這些 subscriptions，否則會產生memory leak。\n 針對單個訂閱做dispose\nlet subscription4 = observable4.subscribe(onNext: { element in print(element) }) subscription4.dispose() 使用disposeBag，當序列完成自動進行dispose\nlet disposeBag = DisposeBag() Observable.of(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .subscribe { print($0) }.disposed(by: disposeBag) 另一種創建序列及訂閱的方法  調用 Observable.create 創建序列，在構建函數裡描述元素的產生過程。\n 當一個序列completed或是出現error就不會再觸發後續的事件\nObservable\u0026lt;String\u0026gt;.create { observer in observer.onNext(\u0026#34;A\u0026#34;) observer.onCompleted() observer.onNext(\u0026#34;B\u0026#34;) observer.onNext(\u0026#34;C\u0026#34;) return Disposables.create() }.subscribe { print($0) } onError: { print($0) } onCompleted: { print(\u0026#34;Completed\u0026#34;) } onDisposed: { print(\u0026#34;Disposed\u0026#34;) }.disposed(by: disposeBag) /// 印出結果 A Completed Disposed ","permalink":"https://tientiensmile.github.io/posts/rxswift/rxswift_observable/","summary":"每一個 Observable 就只是一個序列(Sequence)而已。\nsubscribe 一個 observable，以訂閱UISlider為例，當滑動UISlider時值改變就會通知訂閱(subscride)的人。\n建立Observables 建立一個只有一個 element，值為1的observable\nlet observable = Observable.just(1) 建立一個三個element，型別為int的observable\nlet observable2 = Observable.of(1,2,3) 建立一個只有一個element，為int陣列的observable\nlet observable3 = Observable.of([1,2,3]) 用from遍歷陣列中每一個element，相當於observable2\nlet observable4 = Observable.from([1,2,3]) 建立Subscriptions observable4.subscribe { event in print(event) } /// 印出結果 next(1) next(2) next(3) completed /// 取得Observable中的值 observable4.subscribe { event in if let element = event.element { print(element) } } /// 較簡易取得element的方法 observable4.subscribe(onNext: { element in print(element) }) /// 印出結果 1 2 3 observable3.subscribe { event in print(event) } /// 印出結果 next([1, 2, 3]) completed 取得Observable中的值","title":"RxSwift - Observable"}]